{"./":{"url":"./","title":"Build environment","keywords":"","body":"Building environment Install Node.js You need to install 8.0 or later versions of Node.js. Download it from the Node.js official website. Install aiot-toolkit npm install aiot-toolkit -g --force # Output as follows: Usage: aiot Args: -v: -- Print version Commands: init [options] create a new project. build [options] build the project server [options] open server for project watch [options] recompile project while file changes release [options] release the project preview [options] preview app in your browser update [options] update tools for project view [options] run server to view rpk resign [options] resign the rpk/rpks packages packages [options] generate the rpk packages installdbg [options] install \"org.hapjs.debugger\" installmkp [options] install \"org.hapjs.mockup\" runapp [options] run app on multiple devices installrun [options] install quickapp background and run getPlatforms [options] get available platform(s) on selected device getConnectedDevices get all connected devices "},"tutorial/getting-started/the-first-program.en.html":{"url":"tutorial/getting-started/the-first-program.en.html","title":"The first program","keywords":"","body":"The first program 1 Run the following command under any directory to establish the program template. aiot init 2 Enter the root directory of the project and run the following command to install the dependency packages. npm install 3 Run the following command under the project root directory to compile. npm run build The directory generated after compiling is saved to /build. You can see the UX file by obtaining the JavaScript file after compiling. The ZIP file generated after compiling is saved to /dist/. Its filename extension is *.rpk. 4 Run the app to check the results. You can run it by: 1) Installing the .rpk file onto the Android phone's storage (connect the phone to computer via USB and copy the .rpk file to the storage of the Android phone). 2) Scanning the QR code using the app (Back button menu → Settings → Scan QR code). You can get the QR code address by visiting http://yourip:port after turning on the HTTP server. // Default port: 12306 npm run server // Specified port npm run server -- --port 12300 5 Monitor source code updates and compile automatically. You can monitor the source code file by running the following command. After source code updates, it will be recompiled automatically. npm run watch Note: \"npm run watch\" can only monitor source code files and can't offer HTTP Server services; therefore, if the phone app says it \"Couldn't update\", you need to run \"npm run server\" in a new command line at the same time. "},"tutorial/getting-started/hello-world.en.html":{"url":"tutorial/getting-started/hello-world.en.html","title":"HelloWorld","keywords":"","body":"HelloWorld This chapter tells you how the project works. You'll learn about compiling, previews, and basic concepts: aiot-toolkit packaging tool, running platform APK, and RPK packages generated by the project. Here's what you'll be able to do after reading: Create new projects Compile projects Install the app platform (loader) on a mobile device Run an RPK package on the app platform Building environment Install the development software (Node.js and aiot-toolkit) and verify it. Go to Building environment to learn more. Creating new projects Once the environment is built, developers can use the global aiot command to create a project template as shown below. is the custom project name. aiot init After the command is executed, the folder will be created in current directory. It will be the project's root folder. This project will contain the native code for Project configuration and Simple pages. Here's how the structure of the root directory will look like: ├── node_modules ├── sign RPK signature module │ └── debug Debugging environment │ ├── certificate.pem Certificate │ └── private.pem Private key ├── src │ ├── Common Public resources and components │ │ └── logo.png Icon configured in manifest.json │ ├── Demo Page directory │ | └── index.ux Page file, the file name doesn't have to be the same as the parent folder │ ├── app.ux App file (used to include public resources) │ └── manifest.json Project configuration file (app description, interface declaration, page routing, etc.) └── package.json Definitions of modules and configuration of the project. \"npm install\" will automatically download the required environment according to this configuration file. This is a brief description of the directory: src: The project source folder node_modules: Project dependent libraries sign: Signature module, only debug signature is supported now. If you're releasing the project for internal testing, add a release folder and online signature. To generate a signature, view openssl in Compiling tools. Compiling projects Install npm dependency In the project root directory, run the following command to install the dependency package (webpack, babel, etc.). npm install Compile projects Run the following command in the root directory to compile and package the project, and generate the RPK package. npm run build After you finish compiling and packaging, build and dist folders will be created in the project's root directory. build: Temporary output, containing compiled page JS, images, etc. dist: Final output, containing RPK files. Project resources of the build directory are compressed into an *.rpk archive. This RPK file will is the final output. Recompile automatically If you want to automatically recompile your project after every time you modify the source code, use the following command: npm run watch Installing the app platform (loader) on a mobile device App platform is an Android app, click here to download. Install and open the app platform on a mobile phone. A notification will appear: App hasn't been installed, tap the Back button to install…. Tap the Back button on the phone to open the menu: Frequently used menu items include: Settings: Used to configure the HTTP server address, and set whether to display logs as well as remote debugging-related configuration. Local installation: Install the RPK package from the mobile file system. Online update: Send the HTTP request again to update the RPK package. Running an RPK package on the app platform There are several ways to download and run the RPK file on the app platform. Select one of the options below (we recommend using HTTP request): HTTP request: App platform accesses the HTTP server to download the RPK package. Local installation: Developers copy the RPK package to the mobile phone. This RPK package will be installed on the app platform using the Local installation option in the menu. 1. HTTP request Start HTTP server Create a new window in the terminal, run the following command in the root directory of the project to start the local server (default port number is 12306). npm run server Custom port (e.g.: 8080) npm run server -- --port 8080 Preview on the phone Go to app platform --> Menu --> tap \"Settings\" --> tap \"Scan the QR code\", and scan the QR code on the terminal window to complete configuration (QR code in the browser also works, the page address is: http://localhost:XXXX). After configuration, tap the Back button on the phone to go back to the homepage. You'll be able to preview after you receive a notification about applied settings. If settings couldn't be applied, check if there are new requests in the terminal window that the \"npm run server\" is running on: \"/bundle\" (i.e.: Download the RPK package). The effect is as shown in the image below: 2. Local installation Copy RPK package to the phone Transfer the RPK package compiled in the /dist directory to a mobile device (e.g., using a USB cable). Local installation of RPK packages Go to app platform --> Menu--> tap \"Settings\" --> tap \"File management\", and select an RPK package from the mobile device to preview. Summary Here you've learned about the folder structure of your project. When compiling your project aiot-toolkit will package source files into an RPK file, which is required for your app to run. If everything runs smoothly, you will be able to preview your app while you're developing it. "},"tutorial/getting-started/development-and-debugging.en.html":{"url":"tutorial/getting-started/development-and-debugging.en.html","title":"Development and debugging","keywords":"","body":"Development and debugging Here we describe the development and debugging methods which will help you locate and solve problems. Here's what you'll be able to do after reading: Use log output Debug remotely Debug browser rendering Using log output 1. Change log level Open the manifest.json file in the \"src\" folder of the project's root directory. Locate the configuration (\"config\"), and modify \"logLevel\" to the lowest level of debug. This will allow all levels of log output. Here's how the code in /src/manifest.json will look like after you do this: { 　\"config\": { 　　\"logLevel\": \"debug\" } } 2. Generate logs in JS If the JS code doesn't run as required, generating logs can help developers quickly locate the problem. To be consistent with the traditional front-end development, use the console object to generate logs: console.debug('debug') console.log('log') console.info('info') console.warn('warn') console.error('error') 3. View logs Open the running platform. You'll see the Show logs button in the lower right corner. Tap it to view logs. You can also use the Android Monitor output of Android Studio to view logs. Remote debugging You can open the Debugging page in Chrome to debug the app on your phone. Here are the steps: Run the following command in the root directory, start the HTTP debug server, and provide debug page requests: npm run debug Open http://localhost:8081 in your browser, and you'll see the QR code. Go to app platform --> Menu --> tap \"Settings\" --> tap \"Scan the QR code\". After scanning, the browser will show this link: Enter the debugging page. Click this link to enter the debugging page. Note: If the version of node you're using is 8.x.x, you'll have to do the following: after running the aiot update --force for the first time, delete the package-lock.json file, run npm install and aiot update --force once; after that, start the debug server by npm run debug. Debug browser rendering The page effects that developers will see in the app platform are rendered by Native, and not by WebView. Browser rendering debugging refers to the rendering that is done by the Browser's WebKit engine. Whenever a rendering effect is inconsistent with Native, Native should prevail. Run the following command in the project's root directory: # Default port: 8080 npm run test:h5 Go to http://localhost:8080/webpack-dev-server in Chrome. You'll see the structure similar to the \"src\" folder. Each ux file here corresponds to an HTML file. Click on the HTML file to debug it. You can preview the page rendered by the browser. The debugging method is the same as that for the regular web pages. Summary So far you've learned how projects are debugged and run. In the next chapters, we'll describe more details. You can skip the sections you're already familiar with and focus on the information you need most in your work. "},"tutorial/getting-started/project-configuration.en.html":{"url":"tutorial/getting-started/project-configuration.en.html","title":"Project configuration","keywords":"","body":"Project configuration Get familiar with the files that describe the whole project (/src/manifest.json) and learn about router and UI display. In this section, you will learn about: Configuring basic app information Configuring page router Configuring page UI display Configuring basic app information Each app should have an exclusive name, icon, etc. Such information should be configured in manifest.json. View details in the Manifest chapter. App package name (package) App package name is the unique identifier that distinguishes it from other apps. After the app package is released, access http://hybrid.miui.com/app/ in your mobile browser to switch to the app. It's recommended to use the com.company.module format, for example: { \"package\": \"com.example.demo\" } App name (name) An app name can contain up to 6 Chinese characters, and be consistent with that in the app store. Our framework allows creating a Home screen shortcut for the app. The app name is displayed below the shortcut. Example: { \"name\": \"Camera\" } App icon (icon) Keep icon corners square (not rounded). There should be no white margins. Example: { \"icon\": \"/Common/logo.png\" } Note: Use absolute path, in which / corresponds to the /src/. App version name and version code (versionName, versionCode) App version name and number are maintained by the developer and saved to the app package. App version name should use the main version.sub version format. App version number is an integer, it starts from 1, and increases by 1 with each release. Example: { \"versionName\": \"1.0\", \"versionCode\": 1 } Lowest platform version (minPlatformVersion) The lowest supported platform version number is not required, and the default value is 100, which identifies the minimum platform version that is compatibly supported by the developer's RPK package. When using new features of the platform's version 1.1 or later (101+ will be marked in the file), make sure the platform version is the earliest minPlatformVersion, in order to avoid errors after being released and running on earlier versions. Example: { \"minPlatformVersion\": \"101\" } Interface configuration list (features) Before using an interface, you need to declare it in your Manifest first. At the top of each interface document, the configuration code that declares the interface is attached. Take the Fetch network request as an example: { \"features\": [ { \"name\": \"system.fetch\" } ] } Configuring page router (router) A router defines the page's actual address and the address to be switched to. If routing wasn't configured for the ux page, it won't participate in the project's compilation. Only one home page file (excluding component files) can exist in a directory. Home page name (router.entry) Home page is opened by default when the app platform launches. The first page needs to be configured with the name of a page in the app, that is, the relative path of the page directory in the directory of /src. Example: Let's assume your project's root directory looks like this: └── src └── Demo Page directory: Stores page resources and component files └── index.ux Page files: Filename doesn't have to be the same as the parent folder (index.ux is recommended) If the home page is the index.ux file in the Demo directory, the page name corresponding to the home page will be Demo. { \"router\": { \"entry\": \"Demo\" } } Page routing object (router.pages) For the page routing object, key is the page name (relative path of the page directory in the /src directory), and value is the specific page routing configuration. Don't use the key repeatedly. The specific page routing configuration (router.pages value) includes: component: File's corresponding ux file name path: Page path, use the page name if it's left blank (page directory's relative path in the /src directory) Example: Let's assume your project's root directory looks like this: └── src |── Demo Page directory: Stores page resources and component files | └── index.ux Page files: Filename doesn't have to be the same as the parent folder (index.ux is recommended) └── Doc └── Layout Page directory: Stores page resources and component files └── index.ux Page files: Filename doesn't have to be the same as the parent folder (index.ux is recommended) If the page name (router.pages key) is Demo, the corresponding page configuration (router.pages value) will include: component: File's corresponding ux file name index path: Page path, which is the page name by default Demo { \"router\": { \"pages\": { \"Demo\": { \"component\": \"index\" }, \"Doc/Layout\": { \"component\": \"index\" } } } } Now, developers can access the index.ux page in the Demo directory via /Demo. Configuring page UI (display) UI display is used to define the UI display related configuration. Supported: Common default page UI display, and Private page UI display. Common default page UI display Common default page UI display is shared by all pages. Take the configuration of the title bar text as an example: { \"display\": { \"titleBarText\": \"Common default title on the page\" } } For a page not configured with private title, Common default title on the page will be used as its title. Private page UI display Private page UI display is configured in the object of display.pages: Key is the page name (keep consistent with the name in the router page), and value is the private page UI display. Take the configuration of the title bar text as an example: { \"display\": { \"pages\": { \"Demo\": { \"titleBarText\": \"Demo page title\" } } } } Summary Now you can configure page routing, UI display, and other items. "},"tutorial/framework/lifecycle.en.html":{"url":"tutorial/framework/lifecycle.en.html","title":"Lifecycle","keywords":"","body":"Lifecycle Understand lifecycle and status of the page, and the lifecycle of the app. Here's what you'll learn after reading: Web page lifecycle: onInit, onReady, onShow, onHide, onDestroy, onBackPress, onMenuPress Page status: Displayed, Hidden, Destroyed App lifecycle: onCreate, onDestroy You can find the code described in this tutorial here: src/Lifecycle directory, src/app.ux document. Web page lifecycle Since the page is rendered through ViewModel, the page lifecycle refers to the ViewModel lifecycle, including commonly seen: onInit, onReady, onShow which are triggered when the page is created. onInit() Shows the VM data (events, props, data) have already been prepared; you can use props and data, as shown below: data: { // Lifecycle document list lcList: [] }, onInit () { this.$page.setTitleBar({ text: 'Lifecycle' }) this.lcList.push('onInit') console.info(`Trigger: onInit`) console.info(`Execute: Get data's lcList attribute: ${this.lcList}`) // Execute: Get data's lcList attribute: onInit } onReady() Indicates that the VM template has been compiled, enabling you to obtain the DOM node (e.g.: this.$element (idxxx)) as shown below: onReady () { this.lcList.push('onReady') console.info(`Trigger: onReady`) console.info(`Execute: Get template nodes: ${this.$rootElement()}`) // Execute: Get template nodes: ... } onShow(), onHide() Multiple pages can be operated through the app at the same time, but only one of the pages can be displayed at any time; this is different from pure front-end development, where the browser page can only have one page at a time, and when a new page is opened from the bookmarks, the previous page is destroyed; however, it is somewhat similar to SPA development, that allows for switching pages, but has shared browser Context. Therefore, switching pages produces a new event: onHide() is invoked when the page is switched to hidden, and onShow() is invoked when the page is shown again. The VM $visible attribute can be used to infer the display status: true indicates displayed, false indicates hidden. onShow () { this.lcList.push('onShow') console.info(`Trigger: onShow`) console.info(`Execute: Get page display status attribute: ${this.$visible}`) // true } onHide () { this.lcList.push('onHide') console.info(`Trigger: onHide`) console.info(`Execute: Get page display status attribute: ${this.$visible}`) // false } onDestroy() Invoked when a page is destroyed. Possible reasons for a page being destroyed are: the user returns to the previous page from the current page, or the user has opened too many pages, and the framework automatically destroys some of the pages to avoid using too many resources. Therefore, the destruction of a page should release some resources for operation, such as: cancel monitoring of interface subscriptions geolocation.susubscribe() The VM $valid attribute can be used to infer whether a page has been destroyed: true indicates the page exists, false indicates it has been destroyed. onDestroy () { console.info(`Trigger: onDestroy`) console.info(`Execute: Page will be destroyed, destroying status: ${this.$valid}, operation of canceling monitoring of interface subscriptions should be done: geolocation.susubscribe()`) // true, about to be destroyed setTimeout(function () { console.info(`Execute: Page has been destroyed, so action won't be executed`) // Page has been destroyed, so action won't be executed }.bind(this), 0) } Hints In onDestroy(), the $valid determination does not have any meaning, because the page is about to be destroyed; however, $valid can be used on the VM import on other pages to infer whether the page exists. Attachment for asynchronous operations such as setTimeout is on the current page, asynchronous calls are not executed when the page is destroyed. onBackPress() After the user taps the physical back button or the back menu button in the top-left corner, the event is triggered when invoking the return API. If the event response method returns true, this indicates no return, and you can handle the business logic yourself (After completion, the developer can invoke the API to return); otherwise, do not return data or return other data indicates that the system logic is followed: return to the previous page. onBackPress () { console.info(`Trigger: onBackPress`) // true: Means to handle it itself; otherwise, it will go back to last page // return true } Hints Interface API used to go back to last page: router.back(), refer to the document: Basic functions --> Page routing onMenuPress() When using the native top title bar, you can use the menu attributes in the manifest.json to set whether the menu in the upper right corner is shown. Please refer to the Manifest chapter. onMenuPress () { this.lcList.push('onMenuPress') console.info(`Trigger: onMenuPress`) } Page status As described above, the app allows multiple pages to exist and operate at the same time but shows only one page at any time. Therefore, each page will be in one of a number of different states. Displayed: The page is the page currently shown by the app, inferred from $visible Hidden: After opening a new page on top of the existing page, the original page is hidden, inferred from $visible Destroyed: After a page is destroyed for any reason, the code on the page will not be executed, inferred from $valid For interface calling and page lifecycle and status, refer to documentation: General > General rules App status Currently, the App lifecycle provides two callback functions, onCreate and onDestroy; in app.ux, as shown below export default { onCreate () { console.info('Application onCreate') }, onDestory () { console.info('Application onDestory') }, // Expose to all pages, and use this.$app.$def.method1() on the page to access method1 () { console.info('This is the app method') }, // Expose to all pages, and use this.$app.$def.data1 on the page to access data1: { name: 'This is the data that stored by the app' }, /**manifest**/ } In the app.ux file, you can find some operations that are independent from the page, for example: importing public JS resources and then exposing them to all pages, accessed through this.$app as shown below: // $app information console.info(`Get: The data of manifest.json's config.data: ${this.$app.$data.name}`) console.info(`Get: Data in app file: ${this.$app.$def.data1.name}`) console.info(`Execute: Method in app file`, this.$app.$def.method1()) Summary Understand the lifecycle of the page and app, helping to better organize the business logic of the page, facilitate operations such as the interaction between pages and resource release. "},"tutorial/framework/page-style-and-layout.en.html":{"url":"tutorial/framework/page-style-and-layout.en.html","title":"Page style and layout","keywords":"","body":"Page style and layout Gain familiarity with layout-specific units and component styles, master the Flex layout model, understand how to dynamically modify the style and import a precompiled LESS. Here's what you'll learn after reading: Length units Setting styles Example of Flex Layout Dynamic style modification Import a precompiled LESS You can find the code described in this tutorial here: src/StyleLayout directory Length units The framework currently only supports length units px and %. Unlike traditional web pages, px is a unit of reference relative to the base width of the project configuration, and has been adapted for mobile screens, with a similar principle to rem Developers simply need to confirm the px value for the framework style by referring to the draft design. The conversion formula for the design draft 1px and framework style 1px is as follows: Design draft 1px / base width of design draft = framework style 1px / base width of the project configuration. Base width of the project configuration: default value of config.designWidth in the project configuration document (/src/manifest.json) is 750. Example: If the design draft width is 640px, and the component a has a width of 100px on the design draft, this can be achieved in two different ways: Option 1: Modify the base width of the project configuration: set the base width of the project configuration to the base width of the design draft, so 1px on the framework style is equal to 1px on the design draft. Set the base width of the project configuration, revise config.designWidth in the project configuration document (/src/manifest.json): { \"config\": { \"designWidth\": 640 } } Set the corresponding framework style for component a: width: 100px; Option 2: Do not modify the base width of the project configuration: if the current base width of the project configuration is set to 750, set the framework style xpx of component a, obtaining 100 / 640 = x / 750 from the conversion formula. Set the corresponding framework style for component a: width: 117px; Setting styles Developers can use inline styles, tag selectors, class selectors, and id selectors to set the style for a component. You can also use parallel selection and descendant selectors to set the style as follows: Example: Inline styles ID selector Class selector Tag selector .tutorial-page { flex-direction: column; } /* Tag selector */ text { color: #0000FF; } /* Class selector (recommended) */ .title { color: #00FF00; } /* ID selector */ #title { color: #00A000; } /* Parallel selection */ .title, #title { font-weight: bold; } /* Descendant selector */ .tutorial-page text { font-size: 42px; } /* Direct descendant selector */ .tutorial-page > text { text-decoration: underline; } export default { onInit () { this.$page.setTitleBar({ text: 'Setting styles' }) } } Example of Flex Layout The Flex layout model is used for the layout of the framework itself. Refer to the following external document for a tutorial on the Flex layout: Flex layout tutorial The div component is the most commonly used Flex, with the characteristics of the Flex layout; the text, a, span, label components are the text containers, other components cannot directly insert text content. Example: item1 item2 .tutorial-page { /* Crossed axes centered */ align-items: center; /* Vertical arrangement */ flex-direction: column; } .tutorial-page > .item { /* Allow to be stretched if there is room left */ /*flex-grow: 1;*/ /* Don't allow to be stretched if there isn't enough room left */ flex-shrink: 0; /* Main axis centered */ justify-content: center; width: 200px; height: 100px; margin: 10px; background-color: #FF0000; } export default { onInit () { this.$page.setTitleBar({ text: 'Flex layout example' }) } } Dynamic style modification There are several ways to dynamically modify the style consistent with the traditional front-end development practices, including but not limited to: Modify class: Update the variable in the class attribute of the component Modify inline style: Update the CSS value in the style attribute of a component Tap here to change the font color Tap here to change the font color .normal-text { font-weight: bold; } .text-blue { color: #0faeff; } .text-red { color: #f76160; } export default { data: { className: 'text-blue', textColor: '#0faeff' }, onInit () { this.$page.setTitleBar({ text: 'Modify the style dynamically' }) }, changeClassName () { this.className = 'text-red' }, changeInlineStyle () { this.textColor = '#f76160' } } Import a precompiled LESS For LESS syntax, please refer to sources such as the book called LESS Language Features. To use LESS, please install the appropriate class library: less, less-loader. For details, please refer to the document: style --> precompiled style. Then add the attribute lang=\"less\" to the label. Example: \"less\" example! /* Introduce \"less\" file from outside */ @import './style.less'; /* Use \"less\" */ .tutorial-page { justify-content: center; background-color: #00beaf; #title { color: #FF0000; } } export default { onInit () { this.$page.setTitleBar({ text: 'Introduce \"less\" for precompiling' }) } } Summary After learning about page styles and layouts, developers can start to design and develop pages. "},"tutorial/framework/framework-instructions.en.html":{"url":"tutorial/framework/framework-instructions.en.html","title":"Framework commands","keywords":"","body":"Framework commands Learn about the commands and components provided by the framework: for, if, show, block, and slot. Here's what you'll be able to use after reading: \"for\" command \"if\" and \"show\" commands \"block\" component \"slot\" component You can find the code described in this tutorial here: src/Directive directory \"for\" command \"for\" command is used for the loop output of arrays, for example: {{$idx}}.{{$item.name}} {{$idx}}.{{value.name}} {{personIndex}}.{{personItem.name}} .tutorial-page { flex-direction: column; .tutorial-row { width: 85%; margin-top: 10px; margin-bottom: 10px; } } export default { onInit () { this.$page.setTitleBar({ text: '\"for\" command' }) }, data: { list: [{name: 'aa'}, { name: 'bb' }] } } When rendering a page, the structure of div.tutorial-row will be duplicated by looping according to the definition of the data list in the script. Note: When custom variables represent array indexes and array elements of \"for\" command, the variable name can't start with $ or _. \"if\" and \"show\" commands \"if \" is a conditional command that refers to the if/elif/else commands which are used to control whether to add or delete components. \"show\" command can decide whether to display components. It's used to control their display status, and won't delete them from the DOM structure. Show hidden items: show: Render while control whether to show Condition command: if: if condition elif: elif condition else: else .tutorial-page { flex-direction: column; } export default { onInit () { this.$page.setTitleBar({ text: '\"if\" command and \"show\" command' }) }, data: { showVar: true, conditionVar: 1 }, onClickShow () { this.showVar = !this.showVar }, onClickCondition () { this.conditionVar = ++this.conditionVar % 3 } } When the \"if/elif\" command value is false, the node will be removed from the page, while when it's true, the component will be inserted into the node dynamically. When the \"show\" command value is true, the node is visible, while when it's false, the component is invisible, and node will still remain in the page DOM structure. Note: \"if/elif/else\" nodes must be adjacent. \"block\" component \"block\" component expresses logical block without corresponding Native component. You can use to implement more flexible \"list/conditional rendering\". For example, use mixed commands of \"for\", \"if\", and \"show\" in . Tap: Control whether to show city City: {{city.name}} Sight: {{$item.name}} .tutorial-page { flex-direction: column; } list, list-item { flex-direction: column; } export default { onInit () { this.$page.setTitleBar({ text: '组件block' }) }, data: { 'showCityList': 1, 'cityList': [ { 'name': '北京', 'showSpots': true, 'spots': [ { 'name': 'Tian'anmen' }, { 'name': 'Badaling Great Wall' } ] }, { 'name': '上海', 'showSpots': false, 'spots': [ { 'name': '东方明珠' } ] } ] }, toggleCityList () { this.showCityList = this.showCityList === 1 ? 0 : 1 } } This example is a little bit complicated and integrates the points mentioned before. Here's the explanation: \"showCityList\" is used to control whether to generate the list elements (i.e. a list of cities) on a page \"cityList\" array represents the city list data that needs to be rendered by the list \"showSpots\" in each element of the \"cityList\" array determines whether to display the spots data for current city These combinations allow expressing complex logic. \"slot\" component \"slot\" node is used to insert content into an extra custom ux component. Typically, a slot component is provided in the template for the custom components, and when the component is introduced to the page, the developer can flexibly define the child content within that custom component. Custom components part1.ux and index.ux can be defined as follows: {{ header }} {{ footer }} export default { props: [ 'header', 'footer' ] } slot node content .component { flex-direction: column; } export default { onInit () { this.$page.setTitleBar({ text: 'Componnetslot' }) }, data: { 'header': 'HEAD', 'footer': 'FOOT' } } Use the \"slot\" component in the child component, so that it can accept the child content that the caller passed in, and dynamically render the child component to get the final page. Summary Commands \"for\", \"if\", \"show\", and \"block\" component are commonly used. Make sure you know how to apply them. "},"tutorial/framework/switching-pages-and-passing-parameters.en.html":{"url":"tutorial/framework/switching-pages-and-passing-parameters.en.html","title":"Switching pages and passing parameters","keywords":"","body":"Switching pages and passing parameters Learn how to open pages, go back, and pass parameters back and forth. Here's what you'll be able to do after reading: Use component a for switching pages and parameter passing Use an interface router for page switching and parameter passing Receive parameters Return parameters You can find the code described in this tutorial here: src/PageParams directory Use component a for switching pages and parameter passing Switch pages Component a can switch to a page within the app by configuring href attribute Example: Switch to parameter receiving page Switch to parameter receiving page Switch to home page In addition, component a also provides the ability use call, text messages, and email functions, and the ability to load web pages. Example: Call the phone Call the message Call the email Load mi.com Parameter passing Using component a for page switching, the '?key=value' method can be used to add parameters to support the variable parameters. Example: Carry the parameter key1 to switch Carry the parameter key2 to switch .tutorial-page { flex-direction: column; justify-content: center; align-items: center; } a { margin-top: 75px; font-size: 30px; color: #09ba07; text-decoration: underline; } export default { data: { title: \"Welcome to Direct service\" }, onInit () { this.$page.setTitleBar({ text: 'Switch pages and deliver parameters by component a' }) } } Use an interface router for page switching and parameter passing Switch pages Before using the router interface, you need to import the module. The parameter URL supported by router.push(OBJECT) is identical to the href attribute of component a. The supported parameter URLs for router.replace(OBJECT) do not support calling, messaging, or emailing. Other functions are the same as push. Example: .tutorial-page { flex-direction: column; justify-content: center; align-items: center; } .btn { width: 550px; height: 86px; margin-top: 75px; border-radius: 43px; background-color: #09ba07; font-size: 30px; color: #ffffff; } // Import the module import router from '@system.router' export default { onInit () { this.$page.setTitleBar({ text: 'Interface router switches pages' }) }, routePagePush () { // Switch to a page within the app router.push({ uri: '/PageParams/receiveparams' }) }, routePageReplace () { // Switch to a page within the app, current page can't go back router.replace({ uri: '/PageParams/receiveparams' }) }, routePageBack () { // Back to last page router.back() }, routePageClear () { // Clear all page records, and only remain current page router.clear() } } Parameter passing The router interface parameter params can set required parameter passing during page redirects. Example: .tutorial-page { flex-direction: column; justify-content: center; align-items: center; } .btn { width: 550px; height: 86px; margin-top: 75px; border-radius: 43px; background-color: #09ba07; font-size: 30px; color: #ffffff; } // Import the module import router from '@system.router' export default { data: { title: 'Welcome to use Flash apps' }, onInit () { this.$page.setTitleBar({ text: 'Interface router switches pages and pass parameters' }) }, routePagePushWithParams () { // Switch to a page within the app router.push({ uri: '/PageParams/receiveparams', params: { key: this.title } }) }, routePageReplaceWithParams () { // Switch to a page within the app, current page can't go back router.replace({ uri: '/PageParams/receiveparams', params: { key: this.title } }) } } Receiving parameters After the developers have mastered the method of passing parameters between pages using component a and the router interface, how are the parameters received? In fact, it is very simple. The receiving method for parameters passed by component a and the interface router is the same: indicate the props attribute in ViewModel, indicate a list of the attributes used. Example: page {{key}} .tutorial-page { flex-direction: column; justify-content: center; align-items: center; } export default { data: { key: '' }, onInit () { this.$page.setTitleBar({ text: 'Receive the parameter' }) // Parameters passed by output page in js console.info('key: ' + this.key) } } Return parameters Developers may encounter the need to return parameters between pages. Example: Suppose there is page A and page B, and you first redirect from Page A to Page B, and then return to Page A from Page B, you need to pass parameters. At this point, the component and interface router passing parameters cannot meet the requirements. However, it can be done with the help of the app level object: this.$app.$data The Page A implementation code is as follows: Switch to page B {{msg}} .tutorial-page { flex-direction: column; justify-content: center; align-items: center; } a { margin-top: 75px; font-size: 30px; color: #09ba07; text-decoration: underline; } export default { data: { msg: '' }, onInit () { this.$page.setTitleBar({ text: 'Page A' }) }, onShow () { // When the page is switched to be visible, check if there is data passed from page B in the global data if (this.$app.$data.dataPageB && this.$app.$data.dataPageB.gotoPage === 'pageA') { // Get data returned to current page from the global data var data = this.$app.$data.dataPageB.params; this.msg = data.msg; } } } The Page B implementation code is as follows: Page B .tutorial-page { flex-direction: column; justify-content: center; align-items: center; } export default { data: { msg: '' }, onInit () { this.$page.setTitleBar({ text: 'Page B' }) }, onHide () { // When the page is switched to be invisible, write the data object to be passed into global data this.$app.$data.dataPageB = { gotoPage: 'pageA', params: { msg: this.msg } } }, updateMsg (e) { // Update the message text input by \"input\" this.msg = e.text; } } Summary Having mastered page switching and parameter passing, developers can easily develop multi-page applications. "},"tutorial/framework/event-monitoring-and-triggering.en.html":{"url":"tutorial/framework/event-monitoring-and-triggering.en.html","title":"Event monitoring and triggering","keywords":"","body":"Event monitoring and triggering Learn about event monitoring API, and how to trigger the ViewModel and component events. Here's what you'll be able to do after reading: Add and remove monitored events: $on(), $off Trigger ViewModel events: $emit() Trigger component events: $emitElement() You can find the code described in this tutorial here: src/BindEvents directory Add and remove monitored events $on is used to monitor custom events; $off removes event monitors. $on(evtName, fnHandler) Register monitored events on the current page. Thus you'll be able to monitor custom events triggered by $emit(), $dispatch(), $broadcast(), etc. This method doesn't affect registered component node events. export default { onInit(){ this.$on('customEvtType1', this.customEvtType1Handler) }, customEvtType1Handler(evt){ // Event type, event parameter console.info(`Trigger event: Type: ${evt.type}, parameter: ${JSON.stringify(evt.detail)}`); } } $off(evtName, fnHandler) To remove event monitor, the parameter fnHandler is an option. If it's passed, only specified responded functions will be removed; if it's not passed, all monitors for this event will be removed. export default { removeEventHandler () { // Don't pass fnHandler: Remove all monitored events this.$off('customEvtType1') // Pass fnHandler: Remove specified monitored functions this.$off('customEvtType1', this.customEvtType1Handler) } } Trigger ViewMode events Some requirements not triggered manually may come out in page interaction, and $emit() can trigger events dynamically by triggering events on current instance. $emit(evtName, evtDetail) Used to trigger the function of current instance's monitored event, and should be used together with $on(). Note: $emit() only triggers events monitored by $on. export default { emitEvent () { this.$emit('customEvtType1', { params: 'Parameter content' }) } } Trigger component events $emitElement() makes it possible to trigger registration component node events, and trigger them dynamically. $emitElement(evtName, evtDetail, id) $emitElement() can trigger registration component node events, while it's invalid for custom components. Events that triggered component nodes: click Component nodes .tutorial-page { flex-direction: column; } export default { onClickHandler (evt) { // Event type, event parameter, target console.info(`Trigger event: Type: ${evt.type}, Parameter: ${JSON.stringify(evt.detail)}, component nodes: ${evt.target && evt.target.id}`); }, emitElement () { this.$emitElement('click', { params: 'Parameter content' }, 'elNode1') } } Summary Mastering the monitoring and triggering events can help developers better separate the business logic and reduce the coupling on the method response. "},"tutorial/framework/parent-child-component-communication.en.html":{"url":"tutorial/framework/parent-child-component-communication.en.html","title":"Parent-child component communication","keywords":"","body":"Parent-child component communication Learn about the development of custom components, understand communication between parent and child components (props, data, $dispatch(), $broadcast()). Here's what you'll be able to do after reading: Write custom components Introduce custom components Transfer and transform data Trigger events between parent-child components: $broadcast(), $dispatch(), child component $emit() node events Organize communication between sibling components You can find the code described in this tutorial here: src/InterVms directory Writing custom components When developing pages, developers must use native components, such as text and div. These components are rendered using the native layer of each platform. When developing complex pages, developers write all of the UI parts into a single , reducing the maintainability of the code and causing unnecessary coupling between modules. In order to better organize the logic and code, the page can be split into multiple modules according to function. Each module is responsible for a single function. The page then imports and manages the modules. Custom components mean the coding for transmission functions and configuration data are entirely separated. A custom component is a component written by developers that works like native, and is rendered using the . As with a page, it uses ViewModel for management of data, events, and methods. From this perspective, pages are also a type of special custom component that can be used without being imported, and which also serve the entire page. There is no need to go into details about ux page development. The following is an example: Custom component: {{ prop1 }} {{ prop2Object.name }} .tutorial-page { flex-direction: column; padding-top: 20px; .tutorial-title { font-weight: bold; } } // Child component export default { props: [ 'prop1', 'prop2Object' ], data: { }, onInit () { console.info(`Data passed from outside: `, this.prop1, this.prop2Object) } } A custom component is different from a page component due the presence of a props attribute, which is used to indicate acceptable external data transfers; props is an array, and each element in the array is an exposed attribute name. Hint If the attribute name uses a hump attribute, such as prop2Object, then use - to join the parts, for example prop2-object during external data transfer. Introducing custom components The traditional way of importing files is to use import and require in ; for example, Vue, React. The framework imports custom components by using the label, as shown by the code below: The src attribute in the label specifies the custom component address; the name attribute specifies the label name when using a component in the The final page definition and import method is as follows Page component: {{ data1 }} {{ data2.name }} Trigger $broadcast() .tutorial-page { flex-direction: column; padding: 20px 10px; .tutorial-title { font-weight: bold; } } // Parent component export default { data: { data1: 'Pass strings', data2: { name: 'Pass objects' } }, onInit () { this.$page.setTitleBar({ text: 'Parent-child component communication' }) }, evtTypeHandler (evt) { console.info(`Parent component: Event response: `, evt.type, evt.detail) // End the event passing // evt.stop() }, evtType1Emit () { this.$broadcast('evtType1', { params: 'Extra parameters' }) } } Transferring and transforming data As described above, the parent component transfers data to the child component, using the props attribute within the child component to indicate the exposed attribute name, then indicating the transferred parent component data on the component import label. If you wish to transform the data on the child component, but do not want to change the parent component data, you can use $watch(). If it is an attribute in the target, please use . to split the parameters, for example: $watch(xxx.xxx.xxx, methodName). This is shown below, target prop1 attribute // Child component export default { props: [ 'prop1', 'prop2Object' ], data () { return { upperProp1: this.prop1 } }, onInit () { console.info(`Data passed from outside:`, this.prop1, this.prop2Object) // Monitor data changes this.$watch('prop1', 'watchPropsChange') this.$watch('prop2Object.name', 'watchPropsChange') }, /** * Monitor data changes, and you can set the value to \"data\" after you process the data * @param newV * @param oldV */ watchPropsChange (newV, oldV) { console.info(`Monitor data changes`, newV, oldV) this.upperProp1 = newV && newV.toUpperCase() } } Triggering events between components After the child component has completed data transformation, there are typically two ways to pass the final data to the parent component. The data transferred by the parent component is the object, and the child component directly modifies the attributes of this object; so, the parent component directly receives the final data. The child component data contains internal data, which needs to be passed to the parent component: the child component uses $dispatch() to complete the event trigger, the parent component uses $on() to attach the event and respond, for example: evtType2; The child component data contains internal data that needs to be given to the parent component: the child component uses $emit() on the event attached to the node to execute the parent component method, for example: evtType3; This is shown in the code below // Child component export default { props: [ 'prop1', 'prop2Object' ], data () { return { upperProp1: this.prop1 } }, onInit () { console.info(`Data passed from outside:`, this.prop1, this.prop2Object) // Custom events with assigned ViewMode this.$on('evtType1', this.evtTypeHandler) this.$on('evtType2', this.evtTypeHandler) }, evtTypeHandler (evt) { console.info(`Child component: Event response: `, evt.type, evt.detail) // End event passing // evt.stop() }, evtType2Emit () { this.$dispatch('evtType2', { params: 'Extra parameters' }) }, evtType3Emit () { this.$emit('evtType3', { params: 'Extra parameters' }) } } Therefore, the framework provides developers with bidirectional event transfer: Transfer down: triggered by the parent component, the child component responds; Invoke parentVm.$broadcast() to complete downward transfer, for example: evtType1 Transfer: triggered by the child component, the parent component responds; invoke childVm.$dispath() to complete upward transfer, for example: evtType2 Hint The transfer parameters for triggering use evt.detail when receiving to get the parameters When the transfer is completed, invoke evt.stop () to end the transfer Communication between sibling components Traditional communication between non-parent-child components such as sibling components is carried out through the Publish/Subscribe model. Developers who want to use this capability can of course write a Pub/Sub model to achieve decoupling; of course, if the business logic is relatively simple, you can also use the VM's own event binding: $on(), $emit(). As shown below, child component defines the logical processing of the sub-terminal, including processMessage() and customEventInVm2(). Using the latter one will have the same effect as using the $on: Custom component 2: Handle messages: {{msg}} Event content: {{eventDetail}} // Child component: part2 export default { props: [ ], data () { return { msg: null, eventDetail: null } }, processMessage (msg) { const now = (new Date).toISOString() this.msg = `${now}: ${msg}` }, /** * Through \"events\" object: Add event */ events: { customEventInVm2 (evt) { const now = (new Date).toISOString() this.eventDetail = `${now}: ${evt.detail}` } } } Another sibling component can use cross references in the parent component to achieve the objective of cross holding of VM. This is achieved by executing establishRef in onReady() in the lifecycle, as shown in the code below: // Parent component export default { onReady () { this.establishRef() }, /** * Establish mutual ViewMode cites */ establishRef () { const siblingVm1 = this.$vm('sibling1') const siblingVm2 = this.$vm('sibling2') siblingVm1.parentVm = this siblingVm1.nextVm = siblingVm2 siblingVm2.parentVm = this siblingVm2.previousVm = siblingVm1 } } The Pub End in the other child component is very simple. Execute sendMesssage() to complete the trigger, as shown in the code below: Custom component 3: Tap to send messages // Child component: part3 export default { sendMesssage () { if (this.previousVm) { // Way1. Citing method this.previousVm.processMessage('The content of communication among brothers') // Way2. Triggering event this.previousVm.$emit('customEventInVm2', 'The content of communication among brothers') } } } Summary Custom components help better organize coding logic and produce a cleaner structure; Understanding data communication between parent and child components is a must-have skill for developing custom components. "},"tutorial/framework/using-async.en.html":{"url":"tutorial/framework/using-async.en.html","title":"Using async","keywords":"","body":"Using async Learn how to use async syntax to develop your app, and replace Callback and Promise in a more neat and elegant way. Here's what you'll be able to do after reading: How to configure async syntax's babel compilation support Use async and await syntax Use async in the native interface You can find the code described in this tutorial here: app.ux in the src/Async directory How to configure async syntax's babel compilation support In the traditional front-end development, async processing methods include Callback, Promise, and Generator. Among them, the latter method tends to be much more readable than the former; the new syntax of async in the ECMA specification can handle asynchronous situations in a more elegant way. Current app platform itself only supports the ES5 syntax. In order to use it, you need to have syntax analysis and conversion tools, for example babel, as well as inject polyfill into the code. Developers should inject babel-runtime/regenerator into app.ux, because this file should be executed before all the page scripts are executed, as shown in the following code: // Script: regenerator.js // Global reference const globalRef = global.__proto__ || global // global injection regeneratorRuntime globalRef.regeneratorRuntime = require('babel-runtime/regenerator') By introducing this script in app.ux, you can inject the support to async. Search for regeneratorRuntime in the build/app.js after the project has been compiled, you will find that it has been injected successfully. Attention: This feature is only supported on aiot-toolkit version 24 or later (because it's required to add library dependencies and modify compilation options) Use async and await syntax For syntax, you can refer to the book called Exploring ES2016 and ES2017 and other available materials. Add the following code to the tutorial export default { data: { }, onInit () { this.$page.setTitleBar({ text: 'supports AsyncAwait' }) }, onReady () { this.testAsync() }, /** * Test Async */ testAsync () { async function bar () { return 'bar' } async function foo() { const ret1 = await bar(); console.info('PAGE: foo: ', ret1) } foo() } } Use async in the native interface To use the native interface with the help of async, you need to transform the native interface from callback to Promise, and define async to return at the same time. The following example describes the transformation of the fetch interface and exposes it to the global environment. // asyncNatives.js import nativeFetch from '@system.fetch' const natives = { /** * Network request * @param options * @return {Promise} */ async fetch (options) { const p1 = new Promise((resolve, reject) => { options.success = function (data, code) { resolve({ data, code }) } options.fail = function (data, code) { resolve({ data, code }) } nativeFetch.fetch(options) }) return p1 } } //Add tp global environment const hookTo = global.__proto__ || global hookTo.natives = natives export default natives Execute the above code first, and expose the natives global variable, so the following code can cite the object, which describes how to call the Fetch interface of async. export default { data: { }, onInit () { this.$page.setTitleBar({ text: 'Support AsyncAwait' }) }, onReady () { this.testNatives() }, /** * Test async's native interface */ async testNatives () { // Success const ret1 = await natives.fetch({ url: 'https://gss0.bdstatic.com/5bd1bjqh_Q23odCf/static/itemrep/bottomBanner/index_9e10f91.js', }) console.info('fetchSuccess result: ', JSON.stringify(ret1)) // Fail const ret2 = await natives.fetch({ url: 'https://gss0.bdstatic.com/xxxxx' }) console.info('fetchFailure result: ', JSON.stringify(ret2)) } } Summary This section isn't a necessary part of development, but provides developers with a more elegant approach for async processing. Learn and use it if you're interested. "},"tutorial/widgets/list-tutorial.en.html":{"url":"tutorial/widgets/list-tutorial.en.html","title":"List tutorial","keywords":"","body":"List tutorial Learn how to use \"list\" correctly, optimize LIST rendering performance, and get the flexibility to meet your needs. Here's what you'll be able to do after reading: Application of scene Performance optimization Display results: Ceiling You can find the code described in this tutorial here: src/ComponentList directory Application of scene Simple scene When developers wish to achieve effects such as a long list or screen scrolling, div components are typically used to create loops, taking a simple list of products as an example. The code for the div component is as follows (see the tutorial document with the corresponding project code): {{$item.name}} {{$item.price}} {{$item.brief}} Load more However, when the DOM structure is complex, the scrolling may become unresponsive because Native is unable to reuse the list elements implemented by the div component. In order to obtain a smooth list scrolling experience, it is recommended that developers use a list component instead of a div component to implement a long list since Native will reuse list-item with the same type of attributes. The code for the list component is as follows (see the tutorial document with the corresponding project code): {{$item.name}} {{$item.price}} {{$item.brief}} Load more In order to implement the reuse of DOM fragments, it is required that DOM structures with the same type attribute are completely identical; so, the list-item setting the same type attribute is the key to optimizing the scrolling performance of the list. Note: Nested list are not allowed within list-item. The type attribute of the list-item is required. When reusing a list-item, internal use of if command is prohibited. This is because the list-item DOM structures with the same type attribute are completely identical, and using if command will cause differences in the DOM structure. If you encounter xxx cannot be cast to xxx at ...list error similar to the figure below: please check the list-item component for the following conditions: The type attribute is not set. Solution: Set the type attribute. if command used internally. Solution: Use the show command instead of the if command, or set a different type attribute. Set to the same type attribute, but the DOM structure is inconsistent. Solution: Set to a different type attribute. Complex scene After understanding the basics of the list component and the key to optimizing performance when implementing a simple list, next, learn about implementing a complex list with multiple types of list elements to further understand list components. If a developer wishes to achieve the effect in the bottom left figure, with an interlaced image display in the product list elements, the elements in the list can clearly be divided into three categories. We set three different type attribute list-item as follows: list-item with image on the left, text on the right, the custom name for the type attribute is productLeft list-item with image on the right, text on the left, the custom name for the type attribute is productRight Load more list-item, the custom name for the type attribute is loadMore After analyzing the categories of list element, as in the structure chart shown in the bottom right: Code is as follows (see the tutorial document with the corresponding project code): {{$item.name}} {{$item.price}} {{$item.brief}} {{$item.name}} {{$item.price}} {{$item.brief}} Load more Performance optimization When the DOM structure is complex, in order to obtain a smooth list scrolling experience, performance optimization of the list components is essential. Performance optimization of the list components is divided into simplified DOM hierarchy, reusing list-item, careful division of list-item, and closing scrollpage. Of these, simplified DOM hierarchy and reusing list-item are essential optimization principles when using list components, while careful division of list-item and closing scrollpage are applied to certain scenes, as described below. Simplified DOM hierarchy Simplifying the DOM hierarchy reduces the number of DOM trees and DOM nodes. Fewer levels and less trees and nodes produce faster layout and drawing. Therefore, developers need to eliminate as much superfluous parcel bundle labels and levels as possible. Reusing list-item Reusing list-item means setting list items with the same DOM structure to the same type attribute list-item. This is key to optimizing the scrolling experience of the list. Careful division of list-Item Careful division of list-item means dividing list-item with the same DOM structure into as small as possible list elements Example: If a developer wishes to achieve the effect in the bottom left figure, products are divided into categories, producing a large number of categories From a business perspective, products can clearly by divided into new product launches, Mi Ecosystem, and load more. It is easy to classify list items by the three types of list-item, as shown in the middle figure. However, when the list is very complex, the middle structure chart divided by business division will still be unresponsive. It is recommended to set aside business logic, and divide the list into list elements that are as small as possible. The structure is divided as shown in bottom right figure. The recommended (upper right) DOM structure code is as follows (see the tutorial document with the corresponding project code): 0?'margin-top':''}}\"> {{$item.title}} {{value.name}} {{value.brief}} {{value.price}} {{$item.textHint}} > Load more Closing scrollpage The list component supports attribute scrollpage. The default setting is off, showing if the non-list elements at the top of the page also scroll with the list. Turning on the scrollpage will reduce the list rendering performance. Therefore, before the developer opens the scrollpage, it is recommended to first try setting the non-list elements at the top of the page as list items with one or more type attribute, and moving them into the list, thereby achieving the objective of closing scrollpage and improving rendering performance. Example: If a developer wishes to achieve the effect in the bottom left figure, the common list is located below the top banner. You need to scroll the entire screen. Developers will generally divide the page into banner and list, then turn on the list scrollpage attribute, as shown in the middle figure: However, turning on scrollpage will reduce the list rendering performance. It is recommended to set the banner as a special type attribute list-item, and move it into the list, while turning off scrollpage, as shown in the bottom left figure. The recommended (upper right) DOM structure code is as follows (see the tutorial document with the corresponding project code): {{$item.name}} {{$item.price}} {{$item.brief}} Load more Display results: Ceiling This section is non-mandatory and is intended as a reference for developers who have one of the following requirements: Need to determine the page scroll position Need to understand appear events and disappear events Realization of a traditional page The ceiling element is an older way of interacting with traditional web pages: The initial position of the ceiling element is generally near the top of the page, but at a distance from the top When the finger slides upward over the initial position of the ceiling element, the ceiling element is pinned to the top When the finger slides down to reach the initial position of the ceiling element, the ceiling element is unpinned from the top In traditional web pages, the idea of the ceiling element is to monitor scroll events. When the page scrolls to a certain position, the position of the ceiling element in the window can be changed. Realization of a framework However, unlike traditional web pages, in the framework, the scroll event applies only to the list component, and the obtained values are the relative coordinates of the scrolling. During use, you need to obtain the current absolute coordinates of the scroll position through accumulation. In addition, when the list is scrolling, this scroll event will be triggered with high frequency, creating potential performance issues. Therefore, within the framework, it is recommended that developers use appear events and disappear events to implement the ceiling effect. The appear event is triggered when the component appears, the disappear event is triggered when the component disappears. The appear event and the disappear event are common events for the component. Components that are indicated as supporting common events in the documentation, including the div component and list-item component, all support these two events. Flexible use of appear events and disappear events can reveal most requirements for determining the scroll position. Implementation and coding of a framework Next, compare to the sample code ceiling element effect rendered in the list component for analysis First, understand top elements and ceiling elements: The top element in the list: the list-item with the top type attribute The ceiling element in the list: the list-item with the ceiling type attribute Then, analyze the solution for producing the ceiling effect: Use the stack component as a container for the entire page. The characteristics of the stack component are as follows: Each direct child component is stacked in sequence, covering the previous child component. In the stack component, add the child component that is last in the sequence as the child component prior to the mask. The display effect is fixed at the top. This mask and the rendering of the ceiling element are exactly the same. When the ceiling effect is required, showing the corresponding mask produces the ceiling effect; when the ceiling element does not need to be shown, hide the corresponding mask. Finally, determine the ceiling conditions:When the page scrolls down, the ceiling element disappears from the field of view, and the ceiling element needs to be pinned the top. Therefore, monitor ceiling element disappear events, showing the mask.When the page scrolls up, the ceiling element appears in the field of view, and the ceiling element needs unpinned from the top. Therefore, monitor ceiling element appear events, hiding the mask.The implementation code is as follows: Top element in the list Ceiling element in the list {{$item}} Ceiling element in the list .tutorial-page { flex-direction: column; .list { width: 750px; flex-grow: 1; .list-item { height: 150px; border-bottom-width: 1px; border-bottom-color: #0faeff; .text { flex: 1; text-align: center; } } } .height-300 { height: 300px; } .bg-red { flex-grow: 1; justify-content: center; background-color: #f76160; } .bg-blue { flex-grow: 1; justify-content: center; background-color: #0faeff; } } export default { data: { maskShow: false, appearCount: 0, list: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N'] }, onInit(){ this.$page.setTitleBar({ text: 'Effect: Ceiling' }) }, showMask () { this.maskShow = true }, hideMask () { // When loading the page, \"appear\" events of all elements will be triggered once. So the first \"appear\" event need to be filtered out. if (this.appearCount) { this.maskShow = false } else { ++this.appearCount } } } SummaryUnderstanding the features of list components can improve page performance, avoiding performance issues in the later stages of the development process "},"tools/toolkit-tools.en.html":{"url":"tools/toolkit-tools.en.html","title":"Toolkit tools","keywords":"","body":"Toolkit tools In order to facilitate the development, aiot-toolkit is provided to help developers to create projects and complete other work using command line tools. Create new projects Used to create a project template aiot init Enter the root directory of the project and run the following command to install the dependency packages npm install Update projects Used to update the regular project directory structure and dependencies Enter the project directory that has been built aiot update Command parameters: -- force: Forced update (Update current project to the aiot-toolkit version. It should be noted that this action may downgrade the version.) After updating, run the \"npm install\" command in the project directory to install the dependency library Command help aiot -h Update tools Currently, you can only update the aiot-toolkit manually. Remove the old aiot-toolkit from the directory, and refer to Building environment to install aiot-toolkit again. After the installation, update the project following the steps above. "},"tools/compiling-tools.en.html":{"url":"tools/compiling-tools.en.html","title":"Compiling tools","keywords":"","body":"Compiling tools Compile and package projects Run this command in the root directory of the project: npm run build Directory of the compiled project is /build Generated app path is /dist/.rpk Publish packages You need to create the release directory in the sign directory of the project, copy and paste the private key file private.pem and the certificate file certificate.pem into it. Required files can be generated by the openssl command, for example: openssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem Run this command in the root directory of the project: npm run release Generated app path is /dist/.signed.rpk If you need to use the debug signature temporarily, you can use npm run release -- --debug Attention: The debug signature's safety can't be guaranteed because it is public. Don't use the debug signature to sign the officially released apps. "},"tools/debugging-tools.en.html":{"url":"tools/debugging-tools.en.html","title":"Debugging tools","keywords":"","body":"Debugging tools The features currently supported on the debugging tools are: Remote debugging Preview on mobile devices Viewing error messages Viewing logs Remote debugging We provided Debug Server for remote debugging of mobile apps. After starting up the Debug Server, register the mobile app on its main page, and open the debugging page to conduct remote debugging. Currently the debugging tool provides basic debugging functions in 4 tabs: Element: Shows the user VDOM page structure and style; Console: Basic console outputs and CLI interaction with the JavaScript engine; Source: The user's source code debugging; Network: Shows user's network requests. Start the Debug Server Execute in the project directory: npm run debug Register mobile app and start debugging After you start using the Debug Server, access the http://localhost:8081 according to the command prompts, then the QR code will be displayed. Tap the Back button on the home page of the debugging app on the user's phone to make the app menu appear, and go to Settings > > \"Scan QR code\" to register the debugging app on the Debug Server. After registration, you will see a link which says \"Open the debugging page\". Click it to enter the debugging page. The usage of the debugging page is exactly the same as that of Chrome's remote debugging tools. Preview on mobile devices When you write code on your PC, the mobile terminal can be easily configured to show how the app runs after the code is changed. Start the debugging environment Run the following command in the project's root directory to launch the local server (default port number is 12306) npm run server Custom port npm run server -- --port XXX Mobile terminal configuration There are two ways to configure the mobile terminal Tap the Back button in the debugging app to open the menu, and tap \"Settings\" \\1. Directly configure the server's IP address and port \\2. Tap to scan the QR code. Enter http://localhost:12306 in the PC browser to show a debugging QR code, scan it to complete configuration After everything is configured, there are 3 ways to preview changes in the mobile terminal 1. Manual compilation + manual refresh Run the following command to complete the compilation, and tap \"Update online\" in the debugging app to preview how current code runs npm run build 2. Manual compilation + auto refresh Run the following command to complete the compilation and auto refresh of the mobile terminal with just one step npm run build && npm run notify 3. Auto compilation + auto refresh Run the following command to launch the file monitor. Every time you modify the project file, the changes will be compiled automatically and refreshed on the mobile terminal npm run watch Viewing error messages If an error occurs while the code is running, the debugging app will show a dialog displaying the stack of errors for your analysis Viewing logs Debugging app Turn on the \"Display logs\" feature (it's off by default) in the Settings. A \"Display logs\" button will appear in the main interface. Tap it to display the current log Command line You need to install the ADB tool first, refer to the instructions on the Official web site. The directory can be added to the system path for later use. In any directory of the PC terminal, run the following command to view the developer's printing logs and other error logs adb logcat -s JsConsole "},"framework/index.en.html":{"url":"framework/index.en.html","title":"Framework","keywords":"","body":"Framework overview This is a framework for app development mainly focusing on front-end development technology stacks. It uses popular front-end development models, which are adjusted to fit the thinking habits of mainstream front-end developers. It also substantially improves the app's performance, offers plenty of options that can be implemented in front-end environments alone, as well as many third-party service docking capabilities. File structure The app is made up of a manifest.json and multiple URL/component UX files. Information such as the app's description, declaration of function permissions, system configuration and URL routing are defined in the manifest.json file. The specific realization of a single web page or component is accomplished in the web page/component UX file, including the UI template, style sheet, data specification, callback event processing, etc. For specific usage, see the File organization chapter. App framework Routing The framework manages the entire web page router of the app, realizes seamless handovers between web pages, and manages the entire lifecycle of the web page. Developers need to register the web page in the manifest.json file, and realize the web page handover in the code through the interface method offered by the framework. For specific usage, see the Manifest and the Page routing chapters. Data binding Data binding makes it extremely easy to keep data and visuals synced. When data is modified, you only need to modify the data in the code, and the visual layer will update correspondingly. For specific use of data binding, see the Template chapter. Interface components The framework offers basic interface components. Apart from supporting commonly used HTML5 tags such as , , and , we also provide the tags related to the native UI, such as , , and . For specific usage, see the Widgets chapter. Native interface The framework also offers many native interface elements, which include the commonly used system and third-party docking capabilities, such as network requests, local storage, Mi Pay, etc. These APIs can greatly decrease the workload for developers, allowing them to work faster. For specific usage, see the Features chapter. "},"framework/file-organization.en.html":{"url":"framework/file-organization.en.html","title":"File organization","keywords":"","body":"File organization App resources An app contains: a manifest that describes the project configuration, an app.ux file that places the project's public source script, multiple UX files that describe the web page/custom components. The following is a typical example: App root directory ├── manifest.json ├── app.ux ├── Page1 │ ├── page1.ux ├── Page2 │ ├── page2.ux └── Common ├── ComponentA.ux ├── ComponentB.ux └── xxx.png The files in the \"Common\" directory are public resource files and component files. The private source files and component files of each page, such as images, CSS, JS, etc., are placed in every web page's directory. File storage The files are stored according to partitions in the application platform, currently the following partitions are supported: Cache: it's used to cache files. For example, files downloaded through the fetch interface will be saved in this partition, the files cached here may be deleted by the system if storage space is insufficient. Files: it's used to save smaller permanent files. The files in this partition are managed by the app itself. Mass: it's used to store larger files. However, this partition can't be guaranteed to always be available. Temp: it indicates a temporary file that has been mapped from outside. For security reasons, temp files are read-only and can only be obtained by calling a special API, e.g. the media.pickVideo method. Moreover, temp files are only temporarily accessible; when the app has been restarted, you can't access the temp file and must get it by calling a special API. Moreover, app resources are processed as a special read-only partition. URI URIs are used to indicate app resources and files. Widgets and features access the app resources and files via the URI. Resource type URI Read-only Example Description App resources /path Yes /Common/header.png - Cache internal://cache/path No internal://cache/fetch-123456.png - Files internal://files/path No internal://files/image/demo.png - Mass internal://mass/path No internal://mass/video/demo.mp4 - Temp internal://tmp/path Yes internal://tmp/xxxxx Generated by the system The characters allowed by the URI are 0-9a-zA-Z_-./%: (not including quotation marks). .. can't appear in the URI, the URI supports directory structure, the directory is separated by a dash '/'. Internal URI indicates private files. That is, when an internal URI is specified, there is no need to specify an app ID, the same internal URI will indicate different files for different apps. Resources and file access rules There are 2 types of app resource paths: absolute and relative paths. Paths that start with \"/\" are absolute paths, e.g. /Common/a.png; paths that don't start with \"/\" are relative paths, e.g. a.png and ../Common/a.png etc. There 2 types of app source files: code and resource files. Code files refer to files that contain code, such as .js/.css/.ux, etc. Other files are source files, this type of file can generally only be used for data, e.g., for images, videos, etc. In a code file, when importing other code files, use a relative path, e.g.: Common/component.ux. In a code file, under normal circumstances, when referencing resource files (such as images, videos, etc.), a relative path should be used, e.g.: ./abc.png. When importing a code file, if the import file is in the same directory as the imported file, and when the imported file references resource files, you can use relative path, but if they are not in the same directory, then you must use an absolute path. This is because when the imported file is compiled, it is copied into the import file, and after it's compiled the directory will change. For example, if the a.css file is imported by the b.ux file, and a.css is in the same directory as b.ux, when a.css references the resource file, you can write a relative path: abc.png. However, if they are not in the same directory, you must write an absolute path: /Common/abc.png. Another example is when the a.ux file is imported by the b.ux file, if the a.ux and b.ux files are in the same directory, when a.ux references the resource file, you can write a relative path: a.png. If they are not in the same directory, when a.ux references the resource file, you must write an absolute path: /Common/abc.png. CSS is consistent with front-end development, use the URL (PATH) method to access the resource file, e.g. url (/Common/abc.png) "},"framework/manifest.en.html":{"url":"framework/manifest.en.html","title":"Manifest","keywords":"","body":"Manifest The manifest.json file contains the app description, interface declaration, and web page routing info. Manifest Attribute Type Default value Required Description package String - Yes App package name. It must be different from the package name of the native app. We recommend using the com.company.module format, e.g.: com.example.demo name String - Yes App name, 6 characters or less, must be consistent with the name in the app market. It's used for displaying the app name under the Home screen icon, pop-up windows, etc. icon String - Yes App icon, 192×192 pixels versionName String - No App version name, e.g.: \"1.0\" versionCode Integer - Yes App version number. Starting from 1, we recommend you to re-upload packages every time and change the version code: versionCode+1 minPlatformVersion Integer 100 No The lowest platform version number supported. The principle is the same as Android API Level. Check compatibility to avoid running on a low version and causing it to be incompatible when going online features Array - No Interface list, the vast majority of interfaces must be declared here, otherwise, they can't be called. View each interface instructions document for details config Object - Yes System configuration information, see below for details router Object - Yes Routing information, see below for details display Object - No UI display related configuration, see below for details config Used to define system configuration and global data. Attribute Type Default value Description logLevel String log Print log levels (off, error, warn, info, log, debug) designWidth Integer 750 The page is designed with a standard width, you can resize the element size according to the actual screen width of the device data Object - Global object target, the attribute name can't start with $ or _, you can visit it through \"this\" on the web page. If the name of the global data attribute and the data attribute in the web page is repeated, then when the web page is initializing, the global data will cover the corresponding attribute value on the web page router Used to define the constitution of the web page and related configuration information. If the routing information isn't configured for the web page, then it will be skipped during compiling. Attribute Type Default value Description entry String - Homepage name pages Object - Page configuration list, the key value is the page name (the corresponding web page directory name, e.g. Hello corresponds to the 'Hello' directory), and the value is the web page detailed configuration page, see below for details router.page Used to define single web page router information. Attribute Type Default value Required Description component String - Yes The component name corresponding to the web page, must be consistent with the UX file name, e.g. 'hello.ux' corresponds to 'hello' path String / No Web page route, e.g. \"/user\", if you don't fill it in the default will be . The path must be unique, it can't be the same as other web page paths.As the the below path is missing, it will be set as \"/Index\": \"Index\": {\"component\": \"index\"} filter 101+ Object - No Declare that the web page can process a request router.page.filter 101+ Declare that a web page can process some request, the web page can be obtained from $page and opening the web page parameters, view script. The filter structure is as follows: \"filter\": { \"\": { \"uri\": \"\" } } Attribute Type Default value Required Description action String - Yes Requested action, currently only supports \"view\" URI Pattern - Yes The matching rule for the requested data. It must be a regular expression. E.g. https?://.* can match all http and https type web pages The filter definition that can process all http and https requests is as follows: \"filter\": { \"view\": { \"uri\": \"https?://.*\" } } display Used to define configuration related to the UI display Attribute Type Default value Description backgroundColor String #ffffff Window background color fullScreen Boolean false Whether or not it is in full screen, the default can't be acted on titleBar at the same time, titleBar must continue to be controlled through titleBar titleBar Boolean true Whether or not to display titleBar titleBarBackgroundColor String - Title bar background color titleBarTextColor String - Title bar text color titleBarText String - Title bar text (you can also skip and transmit the parameter (titleBarText) settings through the web page) menu 101+ Boolean false Whether the menu button is displayed in the top right-hand corner of the title bar pages Object - Display style of each web page, the key is the web page name (consistent with the web page name in the router) Example: { \"package\": \"com.company.unit\", \"name\": \"appName\", \"icon\": \"/Common/icon.png\", \"versionName\": \"1.0\", \"versionCode\": 1, \"minPlatformVersion\": 100, \"features\": [ { \"name\": \"system.network\" } ], \"permissions\": [ { \"origin\": \"*\" } ], \"config\": { \"logLevel\": \"off\" }, \"router\": { \"entry\": \"Hello\", \"pages\": { \"Hello\": { \"component\": \"hello\", \"path\": \"/\", \"filter\": { \"view\": { \"uri\": \"https?://.*\" } } } } }, \"display\": { \"backgroundColor\": \"#ffffff\", \"fullScreen\": false, \"titleBar\": true, \"titleBarBackgroundColor\": \"#000000\", \"titleBarTextColor\": \"#fffff\", \"pages\": { \"Hello\": { \"backgroundColor\": \"#eeeeee\", \"fullScreen\": true, \"titleBarBackgroundColor\": \"#0000ff\", \"titleBarText\": \"Hello\" } } } } "},"framework/source-file.en.html":{"url":"framework/source-file.en.html","title":"Source file","keywords":"","body":"Source file App, the web page, and the custom components are compiled through the UX file. The UX file is composed of the template, style sheet, and script. The following is a typical example of a UX file: Hello {{title}} .container{ flex-direction: column; justify-items: center; } .title { color: red; app.ux Don't delete the annotations from the /**manifest**/, because after compiling the current app.ux, it will contain the manifest configuration information (you can check the file content after npm run build). You can import some public scripts into the and reveal them on the current app's target as shown below. You can then visit it through this.$app.util in the ViewMode of the web page's UX file. import util from './util.js' module.exports = { /**manifest**/, util: util } "},"framework/template.en.html":{"url":"framework/template.en.html","title":"Template","keywords":"","body":"Template Tag language similar to HTML. It combines basic components, custom components, and events, builds the structure of a web page. Note: You can only have 1 root node in a template (e.g.: div) Don't have multiple root nodes in the and don't use \"block\" as a root node. Data binding {{message}} module.exports= { data: { message: 'Hello World!' } } Event binding module.exports= { press: function(e) { this.title = 'Hello' } } Writing methods supported by event callbacks (the {{}} among it can be omitted): \"fn\": fn is the name of the event's callback (the corresponding function implementation is in the ). “fn(a,b)”: function parameters such as a and b can be constants or variables defined in the data of the (don't write \"this.\" in the beginning). \"a+b\": expression, among it a and b data categories are the same as the above. When the callback is called, it will automatically add an \"evt\" parameter at the end of the parameters list, and will access the context data corresponding to the callback event (for specifics on data content, see the component callback event instructions), for example, by clicking the click location x or y of the event. List rendering {{$idx}} {{$item.uniqueId}} module.exports = { data: { list: [{ uniqueId: 1 }, { uniqueId: 2 }] } } The for command renders the list according to the source data array, the supported writing style is as follows (you can omit the {{}}). for=\"{{list}}\": list is the source data array, the default array element name is $item. for=\"{{value in list}}\": value is the custom array element name, the default array element index name is $idx. for=\"{{(index, value) in list}}\": index is the custom array element index name, the value is the custom array element name. The tid attribute of the for command is used to specify the unique ID of the array element. If it is unspecified, the array element ($idx) is used by default as the unique ID. The function of the tid attribute is to place an importance on the element node, and optimizing the redrawing efficiency of the \"for\" cycle. In the example code, tid=\"uniqueId\" means using the array element $item.uniqueId of the array list as the unique ID of the array element. When using tid attribute, note that: You must have the data attributes specified by the tid attribute, otherwise it may cause it to run abnormally. You need to guarantee that the data attributes specified in the tid attribute are unique, otherwise it may cause it to run abnormally. Conditional rendering There are 2 types of conditional rendering: \"if/elif/else\" and \"show\". Here's the difference: when 'if' is false, the component will be removed from VDOM, whereas 'show' can't be seen only when rendering, the component will still be in VDOM. \"if/elif/else\" nodes must be neighboring brother nodes, otherwise they can't be processed. Hello-1 Hello-2 Hello-3 module.exports= { data: { show: false } } \"show\" is the same as \"visible=none\". Currently, it's only used for system native components and doesn't have any effect on custom components. Custom components can import parameters via props and can control whether it is visible by using \"show\" in its own interior. Hello module.exports= { data: { visible: false } } Logical control block You can use to implement even more flexible loop/conditional rendering. Note that currently only supports \"for\" and \"if/elif/else\" attributes. If no attribute has been specified, will be treated as a 'transparent' node when building, its child node will be added on to the parent node of the . {{$item.name}} {{$item.address}} module.exports= { data: { cities: [ {name:\"beijing\", spots:[{name:\"XXX\",address:\"XXX\"},{name:\"XXX\",address:\"XXX\"}]}, {name:\"shanghai\", spots:[{name:\"XXX\",address:\"XXX\"},{name:\"XXX\",address:\"XXX\"}]} ] } } Introducing custom components If you haven't set a name attribute, then the SRC file name is used as the component name by default. The SRC attribute specifies the location of the component UX file, you can omit the UX file extension. Note: The component name isn't case sensitive, it will adopt lowercase by default. To bind the event1 event of the custom child component through (on|@)event1 syntax, implement the following parent component method when the event childVm.$emit('event1', { params: 'transmit parameters' }) is triggered: bindParentVmMethod1. The declaration event name on the tag uses a - link. Don't use camel casing to correlate the response with the method, i.e.: use event-type1 to indicate binding eventType1 event. Inserting custom components The location to insert the child component is defined by the tag in the component. The template of the \"com-a\" component is defined as: header footer Use the \"comA\" component on the page as defined below: body When the page renders, the \"comA\" component becomes: header body footer "},"framework/style-sheet.en.html":{"url":"framework/style-sheet.en.html","title":"Style sheet","keywords":"","body":"Style sheet Used to describe the component style of the template, decides how the component should be displayed. The style layout uses the CSS Flexbox style, targeted at some native components, some expansion and modifications have been made to CSS. All size-related styling (e.g. width and font size) uses a standard width (default 750px) as the basis in order to resolve issues with screen adaption. It is re-scaled according to the actual size of the screen, e.g. a width of 100px will actually be 200px on a 1500px wide screen. Importing files There are 2 ways of importing external files @import './style.css'; .a{ } Template internal style Supports use of attributes such as styles and classes to control the style of a component. Selector The supported selectors are: Selector Example Example description . class . intro Select all components with class=\"intro\" #id #firstname Select all components with id=\"firstname\" tag div Select all div components , .a, .b Select all components with class=“.a” and class=“.b” #id .class tag .page .body text Supports ID, class, tag of descendant selectors, you can also use \">\" to indicate direct descendant 101 // Single selector text { } .class-abc { } #idAbc { } // descendant select .doc-page #testTag div text { } .doc-page #test-class .class1 { } .doc-page #testId #testIdId1 { } // direct descendant select .doc-page #testTag .flex-column > text { } // The same style suits multiple selectors .font-text, .font-comma { } Note, changes in the selector declaration may cause the element to be redrawn. In order to reduce the amount of times the DOM updates as a result of selector changes, currently, only modification to the last rule in the multiple selectors declared by CSS to update DOM is supported. .doc-body .row-desc1 { color: #ff0000; }; .doc-body .row-desc2 { color: #0000ff; }; .doc-body2 .row-desc1 { color: #00ff00; }; In the above example, when we take rowDesc variable from the row-desc1 and change it into row-desc2, it notifies the Native to update the node style, but if you were to take docBody variable from doc-body and change it into doc-body2, it won't notify DOM to update. As doc-body isn't the last selector, modifications in non-last selectors may affect many DOM elements, and thus affect the rendering performance. Selector priority The priority calculation of the current style selector is consistent with the browser, it is a subset of the CSS rendering (only supports: inline, ID, class, tag, descendant, direct descendant). The rules for the priority level of the selector are as follows (suppose multiple CSS declarations match the same element div), the overall priority of the CSS declaration applied to that element are these 4 main types: inline > #id > .class > tag. When multiple CSS declarations match one element (e.g., #page .class-div and .page .class-div), their priority is determined by the weight value of each selector. The weight of the ID selector is 10000. The weight of the class selector is 100. The weight of the tag selector is 1. The values of CSS declarations are calculated as follows: The value of #page is 10000. The value of #page .class-div is 10100. The value of #page .class-div text is 10101. The value of #page #body .container div text is 20102. Therefore: When we compare #page .class-div and .page .class-div, the one with a higher value is prioritized. If their values are equal, the later replaces the earlier one according to the declared order. Style preprocessing 101+ Currently supports less and sass preprocessors. @import './lessFile.less'; .page-less { #testTag { .less-font-text, .less-font-comma { font-size: 60px; } } } Pseudo-classes In any component, if an attribute is a Boolean class and when its default value is false, in both instances it's possible to declare a pseudo-class through that attribute's name. When the attribute becomes true, the pseudo-class will take effect. E.g., all of the disabled attributes of a component or checked attribute of an input component, etc. Moreover, some components will have the pseudo-class support of other forms. For example, input components can get the focus point through actively calling the focus method or by the user's operation, and make the focus pseudo-class take effect. For details, see internal instructions of each component. Example for writing a pseudo-class: Click btn { width: 360px; height: 180px; background-color: red; } btn:disabled { background-color: green; } When the disabled attribute of the component becomes true, the style of the disabled pseudo-class will take effect. When it is layered over the original style, the background-color in the example will turn from red to green. "},"framework/script.en.html":{"url":"framework/script.en.html","title":"Script","keywords":"","body":"Script Used to define the web page data and implement the lifecycle interface. Syntax Supports ES6 syntax Module declaration You can import functional modules using the import function, and call the module method in the code (for details, see the file instructions of the Interface chapter). import fetch from \"@system.fetch\" You can also import all the modules at once, e.g. import system from \"@system\" Use the system.network to call the interface method in the code. Code reference For JavaScript code, we recommend using \"import\" to import, e.g.: import utils from '../Common/utils.js' Object Custom data Attribute Type Description data Object/Function The web page's data module can be converted into a json object. The attriubute name can't start with a $ or _, if it is a function, don't use reserved words such as for, if, show, tid, etc. The return results must be an object. When initializing the web page, the result obtained by return implementation of the function acts as the data value. props Array Used to define the component's public attribute list (externally visible), it can be transmitted to the interior of the component via the method. The attribute name must be in lowercase and can't start with $ or _. Don't use reserved words such as for, if, show, tid, etc. The data type of the current public attribute does not support function. Public object Attribute Type Description $app Object App object $page Object Page object $valid Boolean Whether the web page object is valid $visible 101+ Boolean Whether the web page is in the visible to user state App object Accessible through $app Attribute Type Description $def Object Use this.$app.$def to get the object revealed in the app.ux $data Object Use this.$app.$data to get the global data declared in the config.data of the manifest.json Page object Accessible through $page Attribute Type Description action 101+ String To get it, open the action of the current web page. It is only valid when the current page is opened through the matching filter, otherwise it is undefined. See Manifest to learn more. uri 101+ String To get it, open the URI of the current web page. It is only valid when the current page is opened through the matching filter, otherwise it is undefined. See Manifest to learn more. Method Data method Attribute Type Parameters Description $set Function key: String value: Any Add data attribute. It must be used in the \"onInit\" function, otherwise the data binding in the can't take effect: this.$set('key',value) this.$vm('id').$set('key',value) $delete Function key: String Delete data attribute, if used in the onInit function, it will cause the data binding corresponding to to be unable to take effect: this.$delete('key') this.$vm('id').$delete('key') Public methods Attribute Type Parameters Description $element Function id: String component ID Get the DOM object of a specified ID, if there is no specified ID, then return the root component DOM object usage: this.$element('xxx') $root 101 Function None Get top level ViewModel $parent 101 Function None Get the parent ViewModel $child 101 Function id: String component ID Get the ViewMode usage of the specified component of a specified ID: this.$child('xxx') the ID obtained is the div component ViewModel of xxx $vm deprecated Function id: String component ID Replace with the this.$child('xxx') above $rootElement deprecated Function None Replace with the this.$element() above $forceUpdate Function None Force page refresh Event methods Attribute Type Parameters Description $on Function type: String event name handler: Function event handler function Add the event processing handler usage: this.$on('xxxx', this.fn). \"fn\" is the function defined in $off Function type: String event name handler: Function event handler function Delete event processing handler usage: this.$off('xxxx', this.fn) this.$off('xxx') delete all processing handlers of specified event $dispatch Function type: String incident name Usage for sending an event notification to an upper-level component: this.$dispatch('xxx'). Under normal circumstances, it will always transmit the event upward (bubbling), if you want to stop bubbling, call evt.stop() in the handle function $broadcast Function type: String incident name Usage for sending an event notification to a child component: this.$broadcast('xxx'). Under normal circumstances, it will always transmit the event downwards, if you want to stop the transmission, call evt.stop() in the handle function $emit Function type: String event name data: Object event parameters Trigger event, the usage of the corresponding handler parameters called: this.$emit('xxx')``this.$emit('xxx', {a:1}). The transmitted event parameters can be accessed via evt.detail in the event callback, e.g.: evt.detail.a $emitElement Function type: String event name data: Object event parametersid: String component ID (Default-1 represents root element) Trigger component event, usage of the corresponding handler parameter called: this.$emitElement('xxx', null, 'id') this.$emitElement('xxx', {a:1}). The transmitted event parameters can be accessed via evt.detail in the event callback, e.g. evt.detail.a $watch 101+ Function data: String attribute name, supports 'a.b.c.' format, doesn't support array index handler: String event handler function name, the first parameter of the function is the new attribute value, the second parameter is the old attribute value Dynamic additive attribute/event binding, the attribute must be defined in the data, the handler function must be defined in the ; the event will only be triggered when there is a change in the attribute value: this.$watch('a','handler') Web page method Accessible through $page Attribute Type Parameters Description setTitleBar Function text: String title bar text textColor: String text color backgroundColor: String background color Set the title bar usage of the current web page: this.$page.setTitleBar({text:'Hello', textColor:'#FF0000', backgroundColor:'#FFFFFF'}) Lifecycle interface Web page lifecycle Attribute Type Parameters Return value Description When to trigger onInit Function None None Monitor web page initialization Call when the web page has finished initializing, only triggered once onReady Function None None Monitor completion of web page creation Triggered when the web page has been created and can be displayed, only triggered once onShow Function None None Monitor web page display Triggered when web page is entered onHide Function None None Monitor page hiding Triggered when the page is left onDestroy Function None None Monitor web page sign out Triggered when the page is left (doesn't enter navigation stack) onBackPress Function None Boolean Monitor back button action Triggered when the user taps the back button. If the return is true, it means the web page processed the return logic itself; if the return is false, it means it used the default return logic; if there is no return value then it will process as false onMenuPress 101+ Function None None Monitor menu button action Triggered when a user taps the menu button Call order of the web pages's interface life cycle: Open page A: onInit() -> onReady() -> onShow() Open page B in page A: onHide() Return to page A from page B: onShow() Page A return: onBackPress() -> onHide() -> onDestroy() App life cycle 101+ Attribute Type Parameters Return value Description When to trigger onCreate Function None None Monitor app creation Call when app is created onDestroy Function None None Monitor app destruction Trigger when an app is destroyed "},"widgets/common-events.en.html":{"url":"widgets/common-events.en.html","title":"Common events","keywords":"","body":"Common events Name Parameters Description click - Triggered when component is tapped longpress - Triggered when a user presses and holds a component focus - Triggered when component is focused blur - Triggered when component loses focus appear - Triggered when component appears disappear - Triggered when component disappears "},"widgets/common-attributes.en.html":{"url":"widgets/common-attributes.en.html","title":"Common attributes","keywords":"","body":"Common attributes General attributes Name Type Default value Description ID - Unique identifier style - Style declaration class - Reference style list disabled false Indicates whether the current component can be used Rendering attributes Name Type Default value Description for - Loop unroll current tag according to the data list if - Add or delete current tag according to the data Boolean value show - Display or hide the current tag according to the data Boolean value, equivalent to { display: flex | none } For details on rendering attributes operation modes, see the Template chapter. Note: attributes and styles can't be mixed up, you can't set the style in the attribute field. "},"widgets/common-styles.en.html":{"url":"widgets/common-styles.en.html","title":"Common styles","keywords":"","body":"Common styles Name Type Default value Description width | - Use the width required by the component's own content when it isn't set height | - Use the height required by the component's own content when it isn't set padding 0 Shorthand attributes, set all padding properties in a declaration, this attribute can have 1 to 4 values padding-[left|top|right|bottom] 0 margin 0 Shorthand attribute, set all padding properties in a declaration, this attribute can have 1 to 4 values margin-[left|top|right|bottom] 0 border - 0 Shorthand attribute, set all border properties in a declaration, you can set the attributes in the order of width, style and color, when the value isn't set it will be set as the default value border-style dotted | dashed | solid solid Temporarily only supports 1 value, set style for borders of all elements border-width 0 Shorthand attribute, set all border widths of an element in a declaration or set a width for each border individually border-[left|top|right|bottom]-width 0 border-color black Shorthand attribute, set all the border colors of an element in a declaration or set the color for each border individually border-[left|top|right|bottom]-color black border-radius 0 When there are rounded corners, only use border width, when the border-[left|top|right|bottom]-width doesn't have valid rounded corners, only use border-color, border-[left|top|right|bottom]-color isn't valid border-[top|bottom]-[left|right]-radius 0 background 101+ - Supports gradient style, temporarily can't be used alongside background-color and background-image background-color - background-image - Temporarily isn't supported to be used alongside background-color and border-color; doesn't support online image resources, use local image resources opacity 0xff display flex | none flex visibility visible | hidden visible flex - Takes effect when the parent container is , , flex-grow 0 Takes effect when the parent container is , flex-shrink 1 Takes effect when the parent container is , flex-basis -1 Takes effect when the parent container is , position none | fixed none [left|top|right|bottom] - - Note: none of the common styles are required. "},"widgets/animation-styles.en.html":{"url":"widgets/animation-styles.en.html","title":"Animation style","keywords":"","body":"Animation style Name Type Default value Description transform-origin 0px 0px Transform origin position, currently, only the unit px is supported, the format is 50px 100px transform - See the transform operations below animation-name - Conforms with the name of the @keyframes. See @keyframes attributes below animation-delay 0 Currently the units [ s (seconds) | ms (milliseconds) ] are supported animation-duration 0 Currently the units [ s (seconds) | ms (milliseconds) ] are supported animation-iteration-count | infinite 1 Define the number of times an animation is played, it can be set to infinite for unlimited play animation-timing-function linear | ease | ease-in | ease-out | ease-in-out ease animation-fill-mode none | forwards none - Transform operations Name Type translate translateX translateY scale scaleX scaleY rotate | rotateX | rotateY | @keyframes attributes Name Type Default value Description background-color - opacity - width/height - Temporarily doesn't support percentages transform - - Temporarily doesn't support default start values (0%) or a stop values (100%), they must be explicitly specified. "},"widgets/gradient-styles.en.html":{"url":"widgets/gradient-styles.en.html","title":"Gradient style","keywords":"","body":"Gradient style 101+ Gradients can display a smooth transition between 2 or more specified colors, they are used in the same way as CSS gradients. The current framework supports the following gradient effects: Linear gradients Repeating linear gradients Linear gradients/Repeating linear gradients To create a linear gradient, you need to define 2 types of data: 1) transition direction, and 2) transition color. Therefore, you need to define at least 2 colors. Transition direction can be specified by direction or angle. Transition color supports the following 3 ways: red, `#FF0000, rgb(255, 0, 0), rgba(255, 0, 0, 1). Direction: gradient direction background: linear-gradient(direction, color-stop1, color-stop2, ...); background: repeating-linear-gradient(direction, color-stop1, color-stop2, ...); Angle: gradient angle background: linear-gradient(angle, color-stop1, color-stop2); background: repeating-linear-gradient(angle, color-stop1, color-stop2); Parameters Name Type Default value Required Description direction to = [left | right] || [top | bottom] to bottom (top to bottom gradient) No Example: to right (left-to-right gradient) Example: to bottom right (top left to bottom right-hand corner) angle No Coordinates are established at the center of the graph as the origin of the x-axis, the gradient line is the with the y-axis (clockwise). color-stop [|] Yes Display the background color from the start point to the stop area as color Example: #gradient { height: 100px; width: 200px; } /* Start gradient from the top. The starting point is red and slowly transitions to blue */ background: linear-gradient(red, blue); /* 45° angle, gradually transition from red to blue */ background: linear-gradient(45deg, rgb(255,0,0),rgb(0, 0, 255)); /* Left-to-right gradient, form a gradient with a width of 30px between a distance of 90px from the left and 120px (200*0.6) from the right*/ background: linear-gradient(to right, rgb(255,0,0) 90px, rgb(0, 0, 255) 60%); /* Left-to-right gradient, repeating linear gradient area of 10px (20-10) and transparency of 0.5 */ background: repeating-linear-gradient(to right, rgba(255, 0, 0, .5) 10px,rgba(0, 0, 255, .5) 20px); "},"widgets/div.en.html":{"url":"widgets/div.en.html","title":"div","keywords":"","body":"div Overview Basic container Child component Supported Attribute Supports common attributes Style Supports common styles Name Type Default value Required Description flex-direction column | row row No - flex-wrap nowrap | wrap | wrap-reverse nowrap No - justify-content flex-start | flex-end | center | space-between flex-start No - align-items stretch | flex-start | flex-end | center stretch No - align-content stretch | flex-start | flex-end | center | space-between | space-around stretch No - Events Supports common events "},"widgets/list.en.html":{"url":"widgets/list.en.html","title":"list","keywords":"","body":"list Overview ListView container Child component Only supports Attribute Supports common attributes Name Type Default value Required Description scrollpage boolean false No Whether or not to scroll the non-list part at the top of the web page into the visual area along with the list. Starting this attribute will decrease the list's rendering performance Style Supports common styles Name Type Default value Required Description flex-direction column | row column No columns 101+ number 1 No List displays column number Events Name Parameters Description scroll {scrollX:scrollXValue, scrollY:scrollYValue} List slider scrollbottom - The list scrolls to the bottom scrolltop - The list scrolls to the top Method Name Parameters Description scrollTo {index: number(specified location)} The list scrolls to a specified item location "},"widgets/list-item.en.html":{"url":"widgets/list-item.en.html","title":"list-item","keywords":"","body":"list-item Overview The child component of is used to show a specific item in the list, the width fills the list component by default. Child component Supported Attribute Supports common attributes Name Type Default value Required Description type - Yes List-item type, the same list supports multiple list-item types, make sure the same list-item is completely the same as the view layout after rendering. When the type is fixed, use the \"show\" attribute to replace the \"if\" attribute to guarantee that the view layout doesn't change Style Supports style Doesn't support the position style, supports common styles Name Type Default value Required Description column-span 101+ 1 No The column number that the list-item takes up in the list, generally used to display multiple columns in a list Events Supports common events "},"widgets/refresh.en.html":{"url":"widgets/refresh.en.html","title":"refresh","keywords":"","body":"refresh Overview Pull down to refresh container Child component Supported Attribute Name Type Default value Required Description offset 132px No The distance from the top when refreshing component is static refreshing false No Whether the refresh component is refreshing Style Name Type Default value Required Description background-color white No Refresh component background color progress-color black No Refresh component loading color Events Name Parameters Description refresh {refreshing: refreshingValue} Dropdown refresh component, triggers refresh operation "},"widgets/richtext.en.html":{"url":"widgets/richtext.en.html","title":"richtext","keywords":"","body":"richtext Overview Rich text container The text content is directly written in the tag content area, the content format must match the type. Only static content is supported. As real-time compiling is necessary, don't change the text content frequently, so as to avoid causing performance problems. Child component Not supported Attribute Supports common attributes Name Type Default value Required Description type html html Yes Rendered by traditional WEB HTML pages Style Supports style, the height style setting isn't valid. Supports common styles. Events Supports common events "},"widgets/stack.en.html":{"url":"widgets/stack.en.html","title":"stack","keywords":"","body":"stack Overview A basic container, the child components are arranged in a stack, every direct child component is stacked in order of priority, each child component covers the previous one. Child component Supported Attribute Supports common attributes Style Supports div styles Supports common styles Events Supports common events "},"widgets/swiper.en.html":{"url":"widgets/swiper.en.html","title":"swiper","keywords":"","body":"swiper Overview Slider view container Child component Supported Attribute Supports common attributes Name Type Default value Required Description index 0 No Currently displayed child component index autoplay false No Whether to autoplay after finishing rendering interval 3000ms No Time interval for autoplay, in milliseconds indicator true No Whether the indicator is enabled, default is true Style Supports common styles Name Type Default value Required Description indicator-color 0x7f000000 No Indicator fill color indicator-selected-color 0xff33b4ff No Color when indicator is being selected indicator-size 20px No Diameter of indicator component Events Supports common events Name Parameters Description change {index:currentIndex} Triggered when the currently displayed component index changes Method Name Parameters Description swipeTo {index: number (specified location)} Swiper scrolls to index location "},"widgets/tabs.en.html":{"url":"widgets/tabs.en.html","title":"tabs","keywords":"","body":"tabs Overview Tab container Child component Only supports 1 and 1 Attribute Supports common attributes Name Type Default value Required Description index 0 No Current active tab index Style Supports common styles Events Supports common events Name Parameters Description change {index: indexValue} Triggered when child component 'active' changes "},"widgets/tab-bar.en.html":{"url":"widgets/tab-bar.en.html","title":"tab-bar","keywords":"","body":"tab-bar Overview A child component of that is used to display the tab's content area, the child components are arranged horizontally. Child component Supported Attribute Supports common attributes Name Type Default value Required Description mode scrollable | fixed fixed No When the mode is set as scrollable, the width of the component is the set width, when its width is broader than that of the width, the child component can be scrolled horizontally; when the mode is set as fixed, the width of the child component is split equally with the the tab-bar, when its width is broader than that of the tab-bar, the child component will still split the width equally Style Supports common styles Name Type Default value Required height | 100px No Events Supports common events "},"widgets/tab-content.en.html":{"url":"widgets/tab-content.en.html","title":"tab-content","keywords":"","body":"tab-content Overview A child component of `` that is used to display the tab's content area, the height default fills the tab's remaining space, the child components are arranged horizontally. Child component Supported Attribute Supports general attributes Style Supports common styles Events Supports common events "},"widgets/a.en.html":{"url":"widgets/a.en.html","title":"a","keywords":"","body":"a Overview Hyperlink (default is not underlined) Text content and tag content area, supports escape character \"\\\" Child component Only supports span Attribute Supports common attributes Name Type Default value Required Description href - No For supported styles, see the URI parameters in Page routing Additionally:\"href\" can also add parameters through the \"?param1=value1\" method, the parameters can be used through the this.param1 method.\"href\" also supports web address that start with http and https, it will open WebView and load the page after clicking on itExample:```` Style Supports style Supports common styles Events Supports common events "},"widgets/image.en.html":{"url":"widgets/image.en.html","title":"image","keywords":"","body":"image Overview Render image Child component Not supported Attribute Supports common attributes Name Type Default value Required Description src - No The image URI, supports local and cloud paths at the same time, image styles supported include static (png, jpg) and dynamic (gif) alt - No The image placeholder displayed when loading; only supports local image resources Style Supports common styles Name Type Default value Required Description resize-mode cover | contain | stretch | center cover No Image's resizing type resize-mode type Type Description cover Keeps the aspect ratio, shrinks or enlarges, makes the 2 sides larger than or equal to the display boundaries, centers in the display contain Keeps the aspect ratio, shrinks or enlarges, makes the image be displayed completely within the boundaries of the display, centers in the display stretch Doesn't save aspect ratio, fills the display boundaries center Centers, doesn't resize Events Supports common events "},"widgets/progress.en.html":{"url":"widgets/progress.en.html","title":"progress","keywords":"","body":"progress Overview Progress bar Child components Not supported Attributes Supports common attributes Name Type Default value Required Description percent 0 No Current progress (doesn't take effect when the type is circular) type horizontal | circular horizontal No Progress bar type, dynamic modification not supported Style Supports common styles Horizontal progress background color is #f0f0f0. The default width of the circular progress is 32px. When the width settings are inconsistent, the circular icon will have a smaller value for the width. Name Type Default value Required Description color #33b4ff or RGB (51, 180, 255) No Color of progress bar stroke-width 32px No Width of progress bar (doesn't take effect when the type is circular) Events Supports common events "},"widgets/span.en.html":{"url":"widgets/span.en.html","title":"span","keywords":"","body":"span Overview Formatted text, can only be child components of and Child component Not supported Attribute Name Type Default value Required Description ID - No Unique identifier style - No Style declaration class - No Reference style list for - No Loop unrolling current tag according to the data list if - No Add or delete current tag according to the data Boolean value Style Name Type Default value Required Description color 0x8a000000 No Text color font-size 30px No Text size font-style normal | italic normal No font-weight normal | bold normal No text-decoration underline | line-through | none none No - Events Not supported "},"widgets/text.en.html":{"url":"widgets/text.en.html","title":"text","keywords":"","body":"text Overview Text Text content and tag content area, supports escape character \"\\\" Child component Only supports and Attribute Supports common attributes Style Supports common styles Name Type Default value Required Description lines -1 No Number of text lines, -1 means unlimited number of lines color 0x8a000000 No Text color font-size 30px No Text size font-style normal | italic normal No font-weight normal | bold normal No text-decoration underline | line-through | none none No text-align left | center | right left No line-height - No Height of text lines text-overflow clip | ellipsis clip No Takes effect when number of lines has been set Events Supports common events "},"widgets/input.en.html":{"url":"widgets/input.en.html","title":"input","keywords":"","body":"input Overview Provides an interactive interface, accepts users' inputs, default as one-way traffic Child component Not supported Attribute Supports common attributes Name Type Default value Required Description type button | checkbox | radio101+ | text | email | date | time | number | password text No Dynamic modification not supported checked false No The checked status of the current component, can trigger checked pseudo-class, takes effect when the type is checkbox name 101+ - No Name of input component value - No Value of input component Style Supports common styles Name Type Default value Required Description color 0xde000000 No Text color font-size 37.5px No Text size placeholder 37.5px No Prompts for text content, takes effect when the type is text|email|date|time placeholder-color 0x61000000 No Prompts for text color, takes effect when the type is text|email|date|time width | - No Default value is 128px when the type is button height | - No Default value is 70px when the type is button Events Supports common events Supports change events, triggered when the value or checked status of the input component changes Parameters text | email | date | time | number Checkbox Radio Notes name 101+ √ √ value 101+ √ √ √ checked 101+ √ text deprecated √ √ Replace with value Method Name Parameters Description focus {focus:true|false}, default is true when focus isn't transmitted Enables the component to get or lose focus, can trigger a focus pseudo-class, can eject or retract input method when the type is text|email|date|time|number|password "},"widgets/label.en.html":{"url":"widgets/label.en.html","title":"label","keywords":"","body":"label 101+ Overview Define an annotation for an input or textarea component Child component Not supported Attribute Supports common attributes Name Type Default value Required Description target - No Target input component ID Style Supports common styles Supports text styles Events None "},"widgets/picker.en.html":{"url":"widgets/picker.en.html","title":"picker","keywords":"","body":"picker Overview Scroll selector, currently supports 3 types of selectors: ordinary selectors, date selectors and time selectors. The default is an ordinary selector. Child component Not supported Attribute Supports common attributes Name Type Default value Required Description type text | date | time - Yes Dynamic modification not supported start 1970-1-1 No Takes effect when the type is date. Start time. Format is yyyy-MM-dd end 2100-12-31 No Takes effect when the type is date. End time. Format is yyyy-MM-dd range - No Takes effect when the type is text. Value range of the selector selected Current time or 0 No The default value of the selector. When the type is date, the format is yyyy-MM-dd, when the type is time, the format is hh:mm, when the type is text, the value is the index of the range value - No Selector value Style Supports common styles Events Doesn't support click events, supports common events Name Parameters Description change date: {year:year,month:month,day:day}; time: {hour:hour,minute:minute}; text: {newValue:newValue,newSelected:newSelected} Triggered after determining the value selected by the scroll selector (newSelected as index) Method Name Parameters Description show - Show picker "},"widgets/slider.en.html":{"url":"widgets/slider.en.html","title":"slider","keywords":"","body":"slider Overview Slide selector Child components Not supported Attributes Supports common attributes Name Type Default value Required Description min 0 No - max 100 No - step 1 No - value 0 No - Style Supports common styles Name Type Default value Required Description color 0xfff0f0f0 No Background bar color selected-color 0xff009688 No Selected color padding-[left|right] 32px No Left and right-hand side margins Events Supports common events Name Parameters Description change {progress:progressValue} Event triggered after something is dragged "},"widgets/switch.en.html":{"url":"widgets/switch.en.html","title":"switch","keywords":"","body":"switch Overview Switch selection Child component Not supported Attribute Supports common attributes Name Type Default value Required Description checked false No Can trigger a checked pseudo-class Style Supports common styles Events Supports common events Name Parameters Description change {checked:checkedValue} Triggered when a checked status changes "},"widgets/textarea.en.html":{"url":"widgets/textarea.en.html","title":"textarea","keywords":"","body":"textarea Overview Provides an interactive interface, accepts user input, default as multi-lines Child component Not supported Attributes Supports common attributes Style Supports common styles Name Type Default value Required Description color 0xde000000 No Text color font-size 37.5px No Text size placeholder 37.5 No Prompts for text content placeholder-color 0x61000000 No Prompts for text color Events Supports common events Name Parameters Description change {text:newText} Triggered when input content is changed Method Name Parameters Description focus {focus:true|false}, default is true when focus isn't transmitted Enables the component to get or lose focus, can trigger focus pseudo-class, can eject or retract input method "},"widgets/video.en.html":{"url":"widgets/video.en.html","title":"video","keywords":"","body":"video Overview Video player Child component Not supported Attributes Supports common attributes Name Type Default value Required Description src - No URI of the video play content autoplay false No Whether to autoplay after rendering poster - No Video preview poster Styles Supports common styles Events Supports common events Name Parameters Description prepared - Triggered when the video connects start - Triggered when the video starts pause - Triggered when paused finish - Triggered when video finishes error - Triggered when video couldn't play seeking 101+ {currenttime: value(seconds)} Triggered when play progress bar slides seeked 101+ {currenttime: value(seconds)} Triggered when the play progress bar slide is released timeupdate 101+ {currenttime: value(seconds)} Triggered when the play progress bar changes, trigger frequency is 4HZ fullscreenchange 101+ {fullscreen: fullscreenValue} Triggered when the video enters or exits full screen Method Name Parameters Description start - Start playing video pause - Pause playing video setCurrentTime 101+ {currenttime: value(seconds)} Specify video play location requestFullscreen 101+ - Video enters full screen exitFullscreen 101+ - Video exits full screen "},"widgets/web.en.html":{"url":"widgets/web.en.html","title":"web","keywords":"","body":"web 101+ Overview Used to display online HTML pages Child components Not supported Attributes Name Type Default value Required Description src - No Web page address to load Events Supports common events Name Parameters Description pagestart {url: urlString} Triggered when page starts loading pagefinish {url: urlString, canBack: true/false, canForward: true/false} Triggered when page finishes loading titlereceive {title: title} Triggered when page title is received error {errorMsg: errorMsg} Triggered when a page couldn't load Method Name Parameters Description reload Reload page forward View the previous page in history back View the next page in history canForward {callback: Function} Whether you can navigate forwards canBack {callback: Function} Whether you can navigate backwards \"canForward\" callback function return parameters: Parameter Return value type Description canForward Boolean Whether you can navigate forwards \"canBack\" callback function return parameters: Parameter Return value type Description canBack Boolean Whether you can navigate backwards Example: this.$element('web').canForward({ callback: function(e){ if(e){ // Load next URL from browsing history this.$element('web').forward(); }else{ // TODO } }.bind(this) }) "},"features/index.en.html":{"url":"features/index.en.html","title":"Features","keywords":"","body":"Features overview There are 4 types of interface methods: synchronous, asynchronous, callback, and asynchronous callback. The abilities offered by the different interface methods aren't the same. Synchronous A synchronous interface will directly return a call result, the result can be of any type, see the relevant interface document. Example of usage: console.log(JSON.stringify(app.getInfo())) Asynchronous An asynchronous interface will not immediately return a call result, developers must provide a suitable callback function. The asynchronous interface will call the corresponding callback function when the task has ended. The callback functions asynchronous interfaces support are: Callback function Parameter name Type Required Description success data Any Call result, can be any type, see interface usage document Callback returned when call succeeds fail data Any Error message, in general it's a string that describes the error message but may also be a different type, see the interface usage document Callback returned when call fails code Number Error code, if the document hasn't specifically described it, then it will return 200. If other error codes are returned, then you need to list the instructions in the document Callback returned when call fails cancel data Any Call results, generally has no content, see interface usage document Callback returned when a user cancels. This callback supported may be provided in some interface calls that require user interaction complete None None None Callback returned when call is completed The 3 callback functions (success, fail, and cancel) are mutually exclusive. Each time the interface calls it will and can only call 1 of these 3 callback functions, after that it will call the complete callback once more. Example of usage: prompt.showContextMenu({ itemList: ['item1', 'item2'], itemColor: '#ff33ff', success: function(data) { console.log(\"handling callback\"); }, fail: function(data, code) { console.log(\"handling fail, code=\" + code); }, cancel: function(data) { console.log(\"handling cancel\"); }, complete: function() { console.log(\"handling complete\"); }, }) Callback Like the asynchronous interface, the callback interface won't immediately return a call result. Developers must provide a suitable callback function and the callback interface will then call the corresponding callback function. Unlike the asynchronous interface, the callback interface may call the callback function multiple times to return a result. The callback functions callback interfaces support are: Callback function Parameter name Type Required Description callback data Any Call result, can be any type, see interface usage document Callback returned every time a result is obtained, it may call multiple times fail data Any Error message, in general it's a string that describes the error message but may also be a different type, see the interface usage document Callback returned when call fails. Once this callback is called, the callback call can't be called again, and the interface call ends code Number Error code, if the document hasn't specifically described it, then it will return 200. If other error codes are returned, then you need to list the instructions in the document Callback returned when call fails. Once this callback is called, the callback call can't be called again, and the interface call ends Take the geolocation interface (system.geolocation) as an example: If you call geolocation.subscribe to monitor changes in a geographical location, then each time there is a change in the geographical location, it will call the imported callback and return the new location information. If a call results in a fail callback and ends the interface call because a user has refused to grant permission, then the callback will never be called again. Example of usage: geolocation.subscribe({ callback:function(ret){console.log(\"handling callback\");}, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) Asynchronous callback Like asynchronous interfaces, asynchronous callback interfaces won't immediately return a call result, instead developers must provide a suitable callback function. When the interface has finished implementing, it will call the callback to return a result. Unlike asynchronous interfaces, this type of interface only accepts 1 callback. Whether or not the call has succeeded must be determined by evaluating the results returned in the callback. The callback can only be returned once. The callbacks supported by the the asynchronous interface are: Callback function Parameter name Type Required Description callback data Any Call result, can be any type, see interface usage document Callback when getting the result, can only be returned once Example of usage: alipay.pay({ orderInfo:\"order1\", callback:function(ret){console.log(\"handling callback\");} }) Implement callback function correctly Apart from the synchronous interface, none of the interfaces can immediately return a result after invoking a call. Instead, the callback is implemented after a period of time and the return result carried acts as the parameter. At the same time, the web page that is in the interface callback and the final implementation callback web page may be two different web pages. Assuming that the page implementing the interface call is A, then when the callback is implemented at the end, it may be in one of the following 3 states: Web page A is still in the display. Web page A has been switched to the background, the page currently displayed is page B. Page A has already been destroyed. The callback must evaluate the state of the web page, and process it correctly according to its state. The web page has $valid and $visible 101+ attributes. For the Boolean value, to simply evaluate the page status, use: //Whether the web page is valid (hasn't been destroyed) this.$valid // Whether the page is in the background this.$visible For example: You want a page to display the business listings of a user's current geographical position, first, you must call geolocation.getLocation() interface to get the current location information, and then call the fetch.fetch() interface to get the service list. When implementing the geolocation.getLocation() callback, then you must evaluate the different states of the current web page to carry out different operations: If the page is still in the display, continue to call the fetch interface to get the service list. If the page has been switched to the background, then cache the current geographical position. If the page has already been destroyed, then don't do any processing. Code example: geolocation.getLocation({ success:function(data){ if (this.$valid && this.$visible) { // The page is in the current display } else if (this.$valid && !this.$visible) { // The page is in the background } else { // The page has been destroyed } }.bind(this), fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) Pay particular attention to the fact that the callback function of the callback interface can be called multiple times. If after the page has switched to the background or has been destroyed the callback is still returned multiple times, it will affect the reaction speed of the app, and will also cause memory leaks. Therefore we strongly recommend you use any of the following methods to cancel the callback interface calls: Cancel the callback interface call in the web page's onHide or onDestroy function. Evaluate the current status of the page in the callback function, cancel the callback interface call after discovering that the page has switched to the background or has been destroyed. We recommend you use the first method because it can cancel the call more promptly and better avoids additional consumption. For example, a web page calls geolocation.subscribe to record a user's exercise trail. To use the first method to cancel the callback interface call logic, do as follows: Call geolocation.unsubscribe in the onDestroy function to unsubscribe Evaluate the state of the current page in the callback and process as appropriate. Code example: export default { onDestroy () { geolocation.unsubscribe() }, record() { geolocation.getLocation({ success:function(data){ if (this.$valid && this.$visible) { //Page is in the current display, record trail } else if (this.$valid && !this.$visible) { // Page is in the background, record trail } else { // Page has been destroyed, don't process } }.bind(this), fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) } } To use the second method to cancel the callback interface call, do as follows: In the success callback imported by the geolocation.subscribe call, first evaluate the state of the page. If the page has already been destroyed, call geolocation.unsubscribe to unsubscribe. Code example: geolocation.getLocation({ success:function(data){ if (this.$valid && this.$visible) { // Page is in the current display, record trail } else if (this.$valid && !this.$visible) { // Page is in the background, record trail } else { // The page has been destroyed geolocation.unsubscribe() } }.bind(this), fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) 101+ can call the interface method in the app lifecycle callback. This kind of call interface method has nothing to do with the web page, as long as the app is still running, all the interface calls are valid. However, even if that is the case, we still strongly recommend to cancel the call interface call when deciding that the call interface isn't needed. Common error codes Code Meaning 200 General error 201 User rejection 202 Illegal parameter 203 Service not available 204 Request timed out "},"features/system/app.en.html":{"url":"features/system/app.en.html","title":"App context","keywords":"","body":"App context Interface declaration No declaration required Import module import app from '@system.app' or var app = require(\"@system.app\") Interface definition app.getInfo() Get current app information Parameters: None Return value： Parameter name Type Description packageName String App package name icon String File path of app's icon name String App name versionName String App version name versionCode Integer App version number logLevel String Log level source Object App source source Parameter name Type Description packageName String Source app package name, first level source type String Source type, second level source, the values are shortcut, push, url, barcode, nfc, bluetooth, other extra Object Other source-related information related to the type. Extras will be different for different types extra type=shortcut Scene: third level source, means a scene of a shortcut created, the values are dialog (created a platform internal strategy dialog pop-up window), API (created an API interface call), web (H5 station access traffic switch, created when browsing), other original: original source, means the source when shortcut is created Example: console.log(JSON.stringify(app.getInfo())) "},"features/system/log.en.html":{"url":"features/system/log.en.html","title":"Log printing","keywords":"","body":"Log printing Interface declaration No declaration required Import module No import required Interface definition console.debug/log/info/warn/error(message) Print a paragraph of text Parameters: Parameter Type Required Description message String Yes Text to be printed, it can also be formatted text, the rules are the same as the browser console's Example: for (var i=0; i"},"features/system/router.en.html":{"url":"features/system/router.en.html","title":"Page routing","keywords":"","body":"Page routing Interface declaration No declaration required Import module import router from '@system.router' or var router = require(\"@system.router\") Interface definition router.push(OBJECT) Jump to a page in the app Parameters: Parameters Type Required Description uri String Yes The URI you want to jump to can be in the following format:Complete URIs that contain \"schema\"; Using web paths in the app beginning with '/'; e.g.: /about.Using page names within the app that don't start with '/'; e.g.: About.Special format. When URI value is \"/\", the user will be redirected to the page with the path \"/\", and not the start page. Supports URI with \"schema\" elements. Here's how you process such URIs:Find all the page filters set under the app to choose a suitable page processing request (see Manifest).If no suitable page can handle the request, then it will use default strategy to process the request. If the default strategy can't process the request, it will try to use an app in the system to process it.If there is no system app that can process the request, then it will discard the request.The processing logic for the default strategy:If the schema is internal (view File organization), it will determine the file type according to the URI file extension and then call the app in the system again to open the file. params Object No When the data has to be transferred while redirecting, the values can be used with the this.param1. \"param1\" is the name of the json parameter. The matching value of \"param1\" will be simultaneously converted to the string type. Example: // open page by path router.push({ uri: '/about' params: {testId:'1'} }); // open page by name router.push({ uri: 'About' params: {testId:'1'} }); router.replace(OBJECT) Jump to a page in the app, the current page can't return Parameters: Parameter Type Required Description uri String Yes The URI you want to jump to can be in the below format:The path of the page in the app starting with \"/\"; e.g.: /about.The name of the page in the app not starting with \"/\"; e.g.: About.Special format. When URI value is \"/\", the user will be redirected to the page with the path \"/\", and not the start page. params Object No When the data has to be transferred while redirecting, the values can be used with the this.param1. \"param1\" is the name of the json parameter. The matching value of \"param1\" will be simultaneously converted to the string type. Example: router.replace({ uri: '/test' params: {testId:'1'} }) router.back() Go back to the previous page Parameters: None Example: // Page A router.push({ uri: 'B' }) // Page B router.push({ uri: 'C' }) // Page C will go back to page B through back router.back(); // Page B will go back to page A through back router.back(); router.clear() Clear all history, keep only the current page Parameters: None Example: router.clear() router.getLength() Get the number of pages of the current page stack Return value: Type Description Number Number of pages Example: var length= router.getLength() console.log(\"pages' length = \"length); router.getState() Get the status of the current page Return parameters: Parameter name Type Description index Number The location of the current page in the page stack name String The name of the current page path String The path of the current page Example： var page = router.getState() console.log(\"page index = \"+page.index); console.log(\"page name = \"+page.name); console.log(\"page path = \"+page.path); "},"features/system/prompt.en.html":{"url":"features/system/prompt.en.html","title":"Pop-up window","keywords":"","body":"Pop-up window Interface declaration {\"name\": \"system.prompt\"} Import module import prompt from '@system.prompt' or var prompt = require(\"@system.prompt\") Interface definition prompt.showToast(OBJECT) Show toast Parameters: Parameter name Type Required Description message String Yes Text to display duration Number No 0 is short-term, 1 is long-term, default is 0 Example: prompt.showToast({ message:'message' }) "},"features/system/webview.en.html":{"url":"features/system/webview.en.html","title":"Open web page","keywords":"","body":"Opening web page Interface declaration {\"name\": \"system.webview\"} Import module import webview from '@system.webview' or var webview = require(\"@system.webview\") WebView internal API APIs that can be used in web pages opened in WebView system.go(path) Return specified page of the current app Parameters: Parameter name Type Required Description path String Yes The page to return to, e.g.: /detail?param1=value1, if the value of the path is \"/\", then the path jumped to is the \"/\" page, if there is none, then it will jump to the home page Example: system.go(\"/detail?param1=value1\") "},"features/system/fetch.en.html":{"url":"features/system/fetch.en.html","title":"Data request","keywords":"","body":"Data request Interface declaration {\"name\": \"system.fetch\"} Import module import fetch from '@system.fetch' or var fetch = require(\"@system.fetch\") Interface definition fetch.fetch(OBJECT) Get network data Parameters: Parameter name Type Required Description url String Yes Resource URL data String/Object No The requested parameter, it can be a string or a JSON object. If it is a string, its value acts as the request's body, if a Content-Type hasn't been set for the header, then it will set as text/plain by default. If it's a JSON object, then all of its attributes will use urlencode to form a string to act as the request's body, the Content-Type requested will be forcibly set as application/x-www-form-urlencoded. Example: {\"name\": \"abc\",\"count\": 2} header Object No The header requested, all of its attributes will be set to the requested header section. Useragent settings are invalid. Example: {\"Accept-Encoding\": \"gzip, deflate\",\"Accept-Language\": \"zh-CN,en-US;q=0.8,en;q=0.6\"} method String No Default is GET, it can be: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT responseType String No Type of response, it can be: text, json, file, arraybuffer. The default type will be determined by the Content-Type in response header, see to Success return value. timeout Number No Specifies the timeout period(in seconds) to wait for the server to respond. Default value is 10. success Function No The callback returned successfully fail Function No Callback failed, possibly due to permissions failure complete Function No Ended callback (implemented regardless of whether the call fails or succeeds) Success return value: Parameter name Type Description code Integer Server status code data String If the type in the header returned by the server is text/* or application/json, application/javascript, application/xml, the value is the text content; otherwise, it is the URI temp file of the saved temp file. If the content is an image or video, then they can be set to be displayed to the image or video control headers Object All headers of the server response Example: fetch.fetch({ url:\"http://www.example.com\", success:function(data){ console.log(\"title: \" + JSON.parse(data.data).title); }, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) "},"features/system/storage.en.html":{"url":"features/system/storage.en.html","title":"Data storage","keywords":"","body":"Data storage Interface declaration {\"name\": \"system.storage\"} Import module import storage from '@system.storage' or var storage = require(\"@system.storage\") Interface definition storage.get(OBJECT) Read stored content Parameters: Parameter name Type Required Description key String Yes Index default String No If there is no key, default will be returned. If the default hasn't been specified, an empty string with a length of 0 will be returned success Function No Callback succeeded fail Function No Couldn't return callback complete Function No The callback after the implementation finished Success return value: The stored content corresponding to the key Example: storage.get({ key: 'A1', success:function(data){console.log(\"handling success\");}, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) storage.set(OBJECT) Modify stored content Parameters: Parameter name Type Required Description key String Yes Index value String No New value. If the new value is an empty string with a length of 0, it will delete items of data that has the key as its index success Function No Callback succeeded fail Function No Couldn't return callback complete Function No The callback after the implementation finished Example: storage.set({ key: 'A1', value: 'V1', success:function(data){console.log(\"handling success\");}, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) storage.clear(OBJECT) Clear stored data Parameters: Parameter name Type Required Description success Function No Callback succeeded fail Function No Couldn't return callback complete Function No The callback after the implementation finished Example: storage.clear({ success:function(data){console.log(\"handling success\");}, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) storage.delete(OBJECT) Delete stored content Parameters: Parameter name Type Required Description key String Yes Index success Function No Callback succeeded fail Function No Couldn't return callback complete Function No The callback after the implementation finished Example: storage.delete({ key: 'A1', success:function(data){console.log(\"handling success\");}, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) storage.keys(OBJECT) Returns the key names in the store Parameters. Parameter name Types Required Description success Function No Successful callback fail Function No Failure to callback complete Function No Callback at the end of execution success Return value: Parameter name Type Description data Array An array of key names in the store Example: storage.keys({ success: function(data) { console.log(`handling success, keys = ${JSON.stringify(data)}`) }, fail: function(data, code) { console.log(`handling fail, code = ${code}`) } }) "},"features/system/file.en.html":{"url":"features/system/file.en.html","title":"File storage","keywords":"","body":"File storage 101+ Interface declaration {\"name\": \"system.file\"} Import module import file from '@system.file' or var file = require(\"@system.file\") Interface definition file.move(OBJECT) Move the source file to a specified location, for details on the URIs used in the interface, see File organization Parameters: Parameter name Type Required Description srcUri String Yes The URI of the source file, it can't be an app source file path and tmp type URI dstUri String Yes The URI of the target file, it can't be an app source file path and tmp type URI success Function No Successful callback, returns the URI of the target file fail Function No Couldn't return callback complete Function No The callback after the implementation finished Fail return error code Error code Description 202 Parameter error 300 I/O error Example: file.move({ srcUri: \"internal://cache/path/to/file\", dstUri: \"internal://files/path/to/file\", success: function(uri) { console.log(\"move success: \" + uri); }, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) file.copy(OBJECT) Make a copy of the source file and save it to a specified location, for details on the URIs used in the interface, see File organization Parameters: Parameter name Type Required Description srcUri String Yes URI of the source file dstUri String Yes The URI of the target file, it can't be an app source file path and tmp type URI success Function No Successful callback, returns the URI of the target file fail Function No Couldn't return callback complete Function No The callback after the implementation finished Fail return error code Error code Description 202 Parameter error 300 I/O error Example: file.copy({ srcUri: \"internal://cache/path/to/file\", dstUri: \"internal://files/path/to/file\", success: function(uri) { console.log(\"copy success: \" + uri); }, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) file.list(OBJECT) Get the file list in a specified directory, for details on the URIs used in the interface, see File organization Parameters: Parameter name Type Required Description uri String Yes Directory URI, it can't be an app source file path and tmp type URI success Function No Successful callback, returns {filelist:[{uri:'file1',lastModifiedTime:1234456, length:123456} ...]} fail Function No Couldn't return callback complete Function No The callback after the implementation finished Success return value: Parameter name Type Description fileList Array File list, the format of each file is {uri:'file1',lastModifiedTime:1234456, length:123456} The meta information of every file Parameter name Type Description uri String The file URI, this URI can be accessed by other components or features length Number File size, unit B lastModifiedTime Number The timestamp of the saved file, the number of milliseconds from 1970/01/01 00:00:00 GMT to the current time Fail return error code Error code Description 202 Parameter error 300 I/O error Example: file.list({ uri: \"internal://files/movies/\" success: function(data) { console.log(data.fileList) }, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) file.get(OBJECT) Get the file information of a local file, for details on the URIs used in the interface, see File organization Parameters: Parameter name Type Required Description uri String Yes The URI of the file, it can't be an app source file path and tmp type URI success Function No Successful callback, returns {uri:'file1', length:123456, lastModifiedTime:1233456} fail Function No Couldn't return callback complete Function No The callback after the implementation finished Success return value: Parameter name Type Description uri String The file URI, this URI can be accessed by other components or features length Number File size, unit B lastModifiedTime Number The timestamp of the saved file, the number of seconds from 1970/01/01 08:00:00 to the current time Fail return error code Error code Description 202 Parameter error 300 I/O error Example: file.get({ uri: 'internal://files/path/to/file', success: function(data) { console.log(data.uri); console.log(data.length); console.log(data.lastModifiedTime); }, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) file.delete(OBJECT) Delete a locally saved file, for details on the URIs used in the interface, see File organization Parameters: Parameter name Type Required Description uri String Yes The file URI that needs to be deleted, it can't be an app source file path and tmp type URI success Function No Callback succeeded fail Function No Couldn't return callback complete Function No The callback after the implementation finished Fail return error code Error code Description 202 Parameter error 300 I/O error Example: file.delete({ uri: 'internal://files/path/to/file', success: function(data) { console.log(\"handling success\"); }, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) file.writeText(OBJECT) Write text to file Parameters. Parameter name Types Required Description uri String Yes Local file paths, resource file paths and tmp partitions are not supported, files will be created if they do not exist text String Yes String to be written encoding String No Encoding format, default UTF-8 append Boolean No Append mode or not, default false success Function No Successful callback fail Function No Failure to callback complete Function No Callback at the end of execution fail returns the error code. Error code Description 202 Parameter error 300 I/O errors Example: file.writeText({ uri: 'internal://files/work/demo.txt', text: 'test', success: function() { console.log('handling success') }, fail: function(data, code) { console.log(`handling fail, code = ${code}`) } }) file.writeArrayBuffer(OBJECT) Write Buffer to File Parameters. Parameter name Types Required Description uri String Yes Local file paths, resource file paths and tmp partitions are not supported, files will be created if they do not exist buffer Uint8Array Yes Buffer to be written position Number No Offset pointing to the location where the file starts writing data, default 0 append Boolean No Whether it is append mode, default false. When true, the position parameter is invalid success Function No Successful callback fail Function No Failure to callback complete Function No Callback at the end of execution fail returns the error code. Error code Description 202 Parameter error 300 I/O errors Example: file.writeArrayBuffer({ uri: 'internal://files/work/demo', buffer: buffer, success: function() { console.log('handling success') }, fail: function(data, code) { console.log(`handling fail, code = ${code}`) } }) file.readText(OBJECT) Reading text from a file Parameters. Parameter name Types Required Description uri String Yes Local file path encoding String No Encoding format, default UTF-8 success Function No Successful callback fail Function No Failure to callback complete Function No Callback at the end of execution success Return value: Parameter name Types Description text String Text to be read fail returns the error code. Error code Description 202 Parameter error 300 I/O errors 301 File does not exist Example: file.readText({ uri: 'internal://files/work/demo.txt', success: function(data) { console.log('text: ' + data.text) }, fail: function(data, code) { console.log(`handling fail, code = ${code}`) } }) file.readArrayBuffer(OBJECT) Read Buffer from file Parameters. Parameter name Types Required Description uri String Yes Local file path position Number No The default value is the starting position of the file to be read length Number No The length of the read, or the end of the file is read if not filled in success Function No Successful callback fail Function No Failure to callback complete Function No Callback at the end of execution success Return value: Parameter name Types Description buffer Uint8Array Contents of the file to be read fail returns the error code. Error code Description 202 Parameter error 300 I/O errors 301 File does not exist Example: file.readArrayBuffer({ uri: 'internal://files/work/demo', position: 100, length: 100, success: function(data) { console.log('buffer.length: ' + data.buffer.length) }, fail: function(data, code) { console.log(`handling fail, code = ${code}`) } }) file.access(OBJECT) Determine if a file or directory exists Parameters. Parameter name Types Required Description uri String Yes Directory or file uri, cannot be an application resource path and tmp type uri. Support for application resource paths success Function No Successful callback fail Function No Failure to callback complete Function No Callback at the end of execution fail returns the error code. Error code Description 202 Parameter error 300 I/O errors Example: file.access({ uri: 'internal://files/test', success: function(data) { console.log(`handling success`) }, fail: function(data, code) { console.log(`handling fail, code = ${code}`) } }) file.mkdir(OBJECT) Create a directory Parameters. Parameter name Types Required Description uri String Yes directory uri, not uri of application resource paths and type tmp recursive Boolean No Whether to recursively create the directory after creating the directory's parent directory. Default false success Function No Successful callback fail Function No Failure to callback complete Function No Callback at the end of execution fail returns the error code. Error code Description 202 Parameter error 300 I/O errors Example: file.mkdir({ uri: 'internal://files/dir/', success: function(data) { console.log(`handling success`) }, fail: function(data, code) { console.log(`handling fail, code = ${code}`) } }) file.rmdir(OBJECT) Delete Directory Parameters. Parameter name Types Required Description uri String Yes directory uri, not uri of application resource paths and type tmp recursive Boolean No Whether to recursively delete subfiles and subdirectories. Default false success Function No Successful callback fail Function No Failure to callback complete Function No Callback at the end of execution fail returns the error code. Error code Description 202 Parameter error 300 I/O errors Example: file.rmdir({ uri: 'internal://files/dir/', success: function(data) { console.log(`handling success`) }, fail: function(data, code) { console.log(`handling fail, code = ${code}`) } }) "},"features/system/geolocation.en.html":{"url":"features/system/geolocation.en.html","title":"Geographical location","keywords":"","body":"Geolocation Interface declaration {\"name\": \"system.geolocation\"} Import module import geolocation from '@system.geolocation' or var geolocation = require(\"@system.geolocation\") Interface definition geolocation.getLocation(OBJECT) Get geolocation Parameters: Parameter name Type Required Description timeout Long No Set timeout time, unit in ms, the default is 1000. When permission has been denied by the system or the location settings aren't suitable, a result may never be returned, therefore a timeout must be set. After timing out, it will use the fail callback success Function Yes Callback succeeded fail Function No Couldn't return callback, possibly because the user denied permission complete Function No The callback returned after the implementation finished Success return value: Parameter name Type Description longitude Float Longitude latitude Float Latitude Fail return error code 101+ Error code Description 201 User denied, couldn't get location permission Example: geolocation.getLocation({ success:function(data){ console.log(\"handling success: longitude=\" + data.longitude + \", latitude=\" + data.latitude); }, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) "},"features/system/shortcut.en.html":{"url":"features/system/shortcut.en.html","title":"Home screen icons","keywords":"","body":"Home screen icons Interface declaration {\"name\": \"system.shortcut\"} Import module import shortcut from @system.shortcut or var shortcut = require(\"@system.shortcut\") Interface definition shortcut.hasInstalled(OBJECT) Get whether the Home screen icon has been created Parameters: Parameter name Type Required Description success Function No Callback succeeded. Parameters: true = has been created, false = hasn't been created fail Function No Couldn't return callback complete Function No The callback after the implementation finished Example: shortcut.hasInstalled({ success:function(){console.log(\"handling success\");} }); "},"features/system/network.en.html":{"url":"features/system/network.en.html","title":"Network status","keywords":"","body":"Network status Interface declaration {\"name\": \"system.network\"} Import module import network from '@system.network' or var network = require(\"@system.network\") Interface definition network.getType(OBJECT) Get network type Parameters: Parameter name Type Required Description success Function No Callback succeeded fail Function No Couldn't return callback, possibly due to lack of permission complete Function No The callback returned after the implementation finished Success return value: Parameter name Type Description type String Network type, possible values are 2G, 3G, 4G, Wi-Fi, none Example: network.getType({ success:function(data){console.log(\"handling success: \" + data.type);} }) network.subscribe(OBJECT) Monitor network connection status. If called multiple times, it will only take effect the last time Parameters: Parameter name Type Required Description callback Function No Every time the network changes a callback will be returned fail Function No Couldn't return callback, possibly due to lack of permission Callback return value: Parameter name Type Description metered Boolean Whether it's billed according to the data plan type String Network type, possible values are 2G, 3G, 4G, Wi-Fi, none Example: network.subscribe({ callback:function(data){console.log(\"handling callback\");} }) network.unsubscribe() Cancel monitoring network connection status Parameters: None Example: network.unsubscribe() "},"features/system/device.en.html":{"url":"features/system/device.en.html","title":"Device information","keywords":"","body":"Device information Interface declaration {\"name\": \"system.device\"} Import module import device from '@system.device' or var device = require(\"@system.device\") Interface definition device.getInfo(OBJECT) Get device information Parameters: Parameter name Type Required Description success Function No Callback succeeded fail Function No Couldn't return callback complete Function No The callback returned after the implementation finished Success return value: Parameter value Type Description brand String Device brand manufacturer String Device manufacturer model String Device model number product String Device code name osType String Operating system name osVersionName String Operating system version name osVersionCode Integer Operating system version code platformVersionName String Running platform version name platformVersionCode Integer Running platform version code language String System language region String System region screenWidth Integer Screen width screenHeight Integer Screen height Example: device.getInfo({ success:function(ret){console.log(\"handling success\");} }) "},"features/system/media.en.html":{"url":"features/system/media.en.html","title":"Multimedia","keywords":"","body":"Multimedia Interface declaration {\"name\": \"system.media\"} Import module import media from '@system.media' or var media = require(\"@system.media\") Interface definition '} | | fail | Function | No | Couldn't return callback | | complete | Function | No | The callback returned after the implementation finished | ##### Success return value: | Parameter name | Type | Description | | -------------- | ------ | ------------------ | | uri | String | Selected file path | ##### Fail return error code `101+` | Error code | Description | | ---------- | ---------------------------------------- | | 201 | User denied, couldn't get camera permissions | #### Example: ``` media.takeVideo({ success:function(data){console.log(\"handling success: \" + data.uri);}, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) ``` ### media.pickImage(OBJECT) Select an image #### Parameters: | Parameter name | Type | Required | Description | | -------------- | -------- | -------- | ---------------------------------------- | | cancel | Function | No | Cancel callback | | success | Function | No | Callback succeeded | | fail | Function | No | Couldn't return callback | | complete | Function | No | The callback returned after the implementation finished | ##### Success return value: | Parameter name | Type | Description | | -------------- | ------ | ------------------ | | uri | String | Selected file path | #### Example: ``` media.pickImage({ success:function(data){console.log(\"handling success: \" + data.uri);} }) ``` ### media.pickVideo(OBJECT) Select a video #### Parameters: | Parameter name | Type | Required | Description | | -------------- | -------- | -------- | ---------------------------------------- | | cancel | Function | No | Cancel callback | | success | Function | No | Callback succeeded | | fail | Function | No | Couldn't return callback | | complete | Function | No | The callback returned after the implementation finished | ##### Success return value: | Parameter name | Type | Description | | -------------- | ------ | ------------------ | | uri | String | Selected file path | #### Example: ``` media.pickVideo({ success:function(data){console.log(\"handling success: \" + data.uri);}, fail: function(data, code) { console.log(\"handling fail, code=\" + code); } }) ``` --> media.playRingtone(OBJECT) Play system background sound. Parameters: Parameter name Type Required Description type String No It should be navigation currently. scene String Yes The scene that the sound should be played at. It can be normal or boundary. Return value: No return value. Example: media.playRingtone({ type: 'navigation', scene: 'boundary' }) "},"features/service/push.en.html":{"url":"features/service/push.en.html","title":"Push","keywords":"","body":"Push Interface declaration {\"name\": \"service.push\"} Import module import push from '@service.push' or var push = require(\"@service.push\") Interface definition push.getProvider(OBJECT) Get the provider of push service. Parameters: Parameter name Type Required Description success Function No Callback succeeded, returns the name of provider. fail Function No Couldn't return callback, reason it couldn't return complete Function No The callback returned after the implementation finished Example: push.getProvider({ success: function(data) { console.log(\"push.subscribe succeeded, result data=\" + JSON.stringify(data)); }, fail: function(data, code) { console.log(\"push.subscribe failed, result data=\" + JSON.stringify(data) + \", code=\" + code); }, complete: function() { console.log(\"push.subscribe completed\"); } }); Sending messages Sending from the operating platform Operating platform address: http://admin.xmpush.xiaomi.com Sending from a server Steps: Server import: , includes json-simple-1.1.1.jar and xmpush-server-api-1.0.3.jar Register using appID and appKey allocated by Mi Server. After registering, a regID will be allocated to every device. Send push messages through the appSecret allocated by the Mi server (note: use the debug mode for the app loader test). To send to a single user: to send using regID, call the sendHybridMessageByRegId interface. To send to all users: call the broadcastHybridAll interface. Supports notification shade messages and transparent messages Notification shade messages: a notification will appear on the phone's Notification shade, only when there is an icon on the Home screen will these notifications be received. Transparent messages: You can send data transparently to an app, and it won't appear on the notification, set the callback through the push.on interface, only when the app is active can the payload content be received. Example: public class ServerDemoForHybrid { private static final String APP_SECRET = \"The app's AppSecret\"; private static final String PACKAGE_NAME = \"The app's package name\"; private static final String REGID = \"The regID allocated after registering the app\"; private static final String HYBRID_PATH = \"hybrid_pn\"; public static void main(String[] args) throws Exception { // Send notification shade message testSendNotificationMessage(); // Send transparent transmission message testSendPassThroughMessage(); } /** * Send notification shade message */ public static void testSendNotificationMessage() throws Exception { List list = new ArrayList<>(); list.add(REGID); Sender sender = new Sender(APP_SECRET); Message message = new Message.Builder() .restrictedPackageName(PACKAGE_NAME) .passThrough(0) .notifyType(1) // Notification shade message notification type .notifyId(11) // NotifyID of the notification shade message, the message content will be changed when it's the same .title(\"Test regId message title sdk\") // Title of the notification shade message .description(\"Test regId message desc12\") // The desc of the notification message .extra(HYBRID_PATH, \"/?x=aaa\") // Open the app page path after tapping the notification shade, e.g.: /Detail?xxx=111 & yyy=222 .build(); // Result result = sender.sendHybridMessageByRegId(message, list, 0); // Use this interface when officially online Result result = sender.sendHybridMessageByRegId(message, list, true, 0); // Use this interface when using outgoing app loader test System.out.println(result); } /** * Send transparent message */ public static void testSendPassThroughMessage() throws Exception { List list = new ArrayList<>(); list.add(REGID); Sender sender = new Sender(APP_SECRET); Message message = new Message.Builder() .restrictedPackageName(PACKAGE_NAME) .passThrough(1) .payload(\"Test regId message payload sdk\") // Data of the transparent message .build(); // Result result = sender.sendHybridMessageByRegId(message, list, 0); // Use this interface when officially online Result result = sender.sendHybridMessageByRegId(message, list, true, 0); // Use this interface when using outgoing app loader test System.out.println(result); } } "}}